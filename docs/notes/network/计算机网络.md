---
title: 计算机网络
createTime: 2025/07/21 10:03:43
permalink: /network/gpw6u7bw/
---

#  网络基础

## 什么是因特网

**因特网（Internet）**是一个全球互联的计算机网络系统，能够让世界各地的计算设备进行通信和数据交换。

**OSI（Open Systems Interconnection，开放系统互连）**七层模型是一个标准化的网络架构模型，用于描述和标准化不同计算机系统之间的通信方式。它将网络通信过程分为七个层次，每层各司其职，协同工作，实现端到端的数据传输。

| 层级 | 名称       | 功能描述                                     | 示例                           |
| ---- | ---------- | -------------------------------------------- | ------------------------------ |
| 7    | 应用层     | 提供网络服务和应用程序的直接交互接口         | HTTP, FTP, SMTP, DNS           |
| 6    | 表示层     | 数据格式的转换、加密与解密、压缩与解压       | JPEG, ASCII, SSL/TLS           |
| 5    | 会话层     | 建立、管理和终止会话，确保数据的顺序和同步   | RPC, NetBIOS                   |
| 4    | 传输层     | 提供可靠的端到端数据传输、流量控制、错误恢复 | TCP, UDP                       |
| 3    | 网络层     | 数据包的路由选择和转发，逻辑地址管理         | IP, 路由器, IPv4, IPv6         |
| 2    | 数据链路层 | 节点间的数据传输、错误检测与纠正             | 以太网, Wi-Fi, 交换机, MAC地址 |
| 1    | 物理层     | 定义物理设备标准，信号传输和物理连接接口     | 网线, 光纤, 无线电波, 连接器   |

**五层模型**是对OSI七层模型的简化，更加符合实际应用中的网络协议栈。五层模型将会话层、表示层的功能合并到应用层中。

| 层级 | 名称       | 功能描述                                 | 示例                           |
| ---- | ---------- | ---------------------------------------- | ------------------------------ |
| 5    | 应用层     | 提供网络服务和应用程序的接口             | HTTP, FTP, SMTP, DNS           |
| 4    | 传输层     | 提供可靠的端到端通信                     | TCP, UDP                       |
| 3    | 网络层     | 数据包的路由选择和转发                   | IP, 路由器, IPv4, IPv6         |
| 2    | 数据链路层 | 节点间的数据传输和错误检测与纠正         | 以太网, Wi-Fi, 交换机, MAC地址 |
| 1    | 物理层     | 定义物理设备标准，信号传输和物理连接接口 | 网线, 光纤, 无线电波, 连接器   |

**TCP/IP四层模型**是互联网的基础协议栈模型，它将网络通信过程分为四个层次，比OSI模型更简洁实用。TCP/IP模型更贴近实际网络协议的实现。会话层和表示层合并到应用层。

| 层级 | 名称                            | 功能描述                       | 示例                 |
| ---- | ------------------------------- | ------------------------------ | -------------------- |
| 4    | 应用层（Application）           | 提供应用程序间的通信和数据交换 | HTTP, FTP, SMTP, DNS |
| 3    | 传输层（Transport）             | 提供端到端的通信和数据传输控制 | TCP, UDP             |
| 2    | 互联网层（Internet）            | 处理数据包的路由和转发         | IP, ICMP             |
| 1    | 网络接口层（Network Interface） | 处理物理传输和数据链路层的功能 | 以太网, Wi-Fi        |

**DoD模型（Department of Defense Model）**也称为TCP/IP参考模型，由美国国防部开发，用于描述和实现网络通信。DoD模型与TCP/IP四层模型相似，也分为四个层次。会话层和表示层合并到应用层。

| 层级 | 名称                            | 功能描述                       | 示例                 |
| ---- | ------------------------------- | ------------------------------ | -------------------- |
| 4    | 应用层（Application）           | 提供应用程序间的通信和数据交换 | HTTP, FTP, SMTP, DNS |
| 3    | 传输层（Transport）             | 提供端到端的通信和数据传输控制 | TCP, UDP             |
| 2    | 互联网层（Internet）            | 处理数据包的路由和转发         | IP, ICMP             |
| 1    | 网络接口层（Network Interface） | 处理物理传输和数据链路层的功能 | 以太网, Wi-Fi        |

### 因特网组成

**主机**（Host）是指连接到网络并能够发送或接收数据的设备。主机是网络的重要组成部分，它们可以是各种类型的计算设备，如电脑、服务器、路由器、交换机、智能手机等。

**端系统**（End System）是指直接连接到网络并参与通信的设备。端系统也被称为“主机”（Hosts），它们在网络中扮演重要角色。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQ6ojzaPE7_QLgwwkCkjO6QATWDVwsw0TjxQNdyiEHZPvY?width=1018&height=1236" width="1018" height="1236" />

**端系统** 通过**通信链路**和**分组交换机**的网路连接到一起。这些通信链路由不同类型的物理媒介组成。这些物理媒介包括铜轴电缆、铜线、光纤和无线电频谱组成。不同的链路传输速度不同，链路的传输速率以**比特/秒**（bit/s或bps）度量。当一台端系统向另一台端系统发送数据时，发送端会将数据分段，并为每段加上首部字节。由此形成的信息包成为**分组（packet）**。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。

分组交换机从它的一条通信链路接收到到达的分组，并从它的一条出通信链路转发该分组。如今有两种常用的交换机，一种类型时**路由器（router）**，一种类型是**链路层交换机（link-layer switch）**。这两者类型的交换机都要向最终目的地转发分组。链路层交换机通常用于**接入网**中，路由器通常用于**网络核心**中。从发送端系统到接收端系统，一个分组所经历地一系列通信链路和分组交换机称为通过该网络地**路径（path）**。

端系统通过**因特网服务提供商（Internet Server Provider，ISP）**接入因特网，如本地有线或电话公司运营商提供地住宅区ISP、公司ISP、大学ISP，在机场、旅馆、咖啡店等公共场所提供WIFI接入的ISP，以及智能手机和其他设备提供地蜂窝数据ISP。ISP为端系统提供各种不同类型的网络接入，如**线缆调制解调器**或**DSL**那样的住宅宽带接入、高速局域网接入和移动无线接入。较低层的ISP通过国家、国际的较高层ISP互联，这些较高层的ISP彼此直接互联。无论是较高层的ISP还是较低层的ISP都是独立管理的。

端系统、分组交换机和其他因特网部件都要运行多个**协议（protocol）**，这些协议控制因特网中信息的接受和发送。**TCP（Transmission Control Protocol，传输控制协议）**和**IP（Internet Protocol，网际协议）**是因特网中两个最为重要的协议。**IP**协议定义了在路由器和端系统之间发送和接受的分组格式。因特网主要协议称为**TCP/IP**。

**因特网标准（Internet standard）**由**因特网过程任务组（Internet engineering task force，IETF）**研发。IETF的标准文档称为**请求评论（request for comment，RFC）**。它们定义了TCP、IP、HTTP、和SMTP等协议。目前已经有将近9000个RFC。还有**IEEE802 LAN/MAN标准化委员会**制定了以太网和无线WIFI的标准。

### 服务描述

除了诸如电子邮件、浏览器等传统应用之外，因特网应用还包括移动智能手机和平板电脑应用，这些应用包括流媒体视频、社交媒体、实时服务、多人游戏、导航等。因为这些系统涉及多个相互交换数据的端系统，故他们被称为**分布式应用（distributed application）**。因特网应用运行在端系统上，不运行在网络核心或分组交换机上。

运行在一个端系统上的应用怎样才能“指挥”因特网向运行在另一个端系统上的软件传输数据呢？与因特网相连的端系统提供了一个**套字接口（socket interface）**，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的程序交付数据的方式。

## 什么是协议

**协议**（Protocol）在计算机网络中是指一套规则和标准，用于规范设备之间如何通信和交换数据。协议定义了数据的格式、传输方式、错误检测和纠正方法等内容，以确保不同设备和系统能够有效地进行通信。

在计算机网络和通信中，**报文**（Packet）是一种通过网络传输的基本数据单位。报文包含了发送方要传输的数据以及控制信息，用于确保数据能够正确地到达接收方

一个报文通常由三个部分组成：

1. **报头（Header）**：包含控制信息，如源地址、目的地址、协议类型等。
2. **数据（Data）**：实际传输的数据内容。
3. **尾部（Footer）**：包含错误检测和校验信息，用于保证数据的完整性。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQh6p8n2CBtRbVDyddFUY5tAeH6Wr41LJYRiTyuH4TlLkk?width=484&height=621" width="484" height="621" />

## 网络边缘

我们通常把与因特网相连的计算机和其他设备称为端系统。因为它们位于因特网的边缘，故被称为端系统。

端系统也称为主机，主机又进一步划分为**服务器（server）**和**客户端（client）**。通常来说，客户端主要为智能手机、个人pc等个人电子产品，而服务器是专门提供数据存储、流媒体、应用部署、网页部署等为成百上千人提供服务的高性能计算机。

### 接入网

**接入网**是指将端系统物理连接到其**边缘路由器（edge router）**的网络。**边缘路由器**是端系统到任何其他远程端系统的路径上的第一台路由器。

#### 家庭接入：DSL、电缆、FTTH、5G固定式无线

如今，宽带住宅接入有几种最流行的类型：**数字用户线（DSL）、光纤（FTTH）和电缆**。住户通常从提供本地电话接入的本地电话公司处获得**DSL**因特网接入。因此，在使用**DSL**时，用户的本地电话公司也是它的**ISP**。每个用户的**DSL**调制解调器使用现有的电话线与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据。家庭的**DSL调制解调器(DSL Modem)**得到数字数据后将其转换为高频音，已通过电话线传输给本地中心局；来自许多家庭的模拟型号在DSLAM处被转换回数字形式。住宅电话线同时承载了数据和传统的电话信号，它们用不同的频率进行编码：高速下行通道，位于50kHz~1kHz。中速上行信道，位于4kHz~50kHz。普通的双向电话信道，位于0~4kHz。DSL标准定义了多个传输速率，包括24Mbps、52Mbps的下行传输速率，以及3.5Mbps和16Mbps的上行传输速率。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQSRNyWlv5J8SaIQT9M8LOBdAfC3zKQk_9ErKi4Nymw3rLc?width=992&height=336" width="992" height="336" />

**电缆因特网接入**利用了有线电视公司现有的有线电视基础设施。住宅从提供有线电视的公司获得了电缆因特网接入。光缆将电缆头端连接到地区枢纽，从这里通过传统的同轴电缆到达各个家庭和公寓。每个地区枢纽通常支持500——5000个家庭。因为在这个系统中应用了光纤和同轴电缆，所以它经常被称为**混合光纤同轴（HFC）**系统。电缆因特网接入需要特殊的调制解调器。与DSL调制解调器一样，电缆调制解调器通常是一个外部设备，通过一个以太网端口连接到家庭PC。电缆调制解调器端接系统（CMTS）与DSL网络的DSLAM具有类似的功能，将发送的模拟信号转换回数字信号。电缆调制解调器将HFC网络规划分为上下两个信道。DOCSIS2.0和3.0标准分别定义了40Mbps和1.2Gbps的下行速率以及30Mbps和100Mbps的上行速率。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQSNoxFu05NtRqyBPDPAPrI0ARSbPXsjl9ZeoP2WILyhFLg?width=997&height=450" width="997" height="450" />

**光纤到户（FTTH）**提供了一条从本地中心局直接到家庭的光纤路径。FTTH能够提供大约每秒千兆比特的以太网接入速率。从本地中心局到家庭有几种竞争性的光纤分布方案。最简单的光纤分布网络称为直接光纤，从本地中心局到每户设置一根光纤。更为一般的是，从中心局出来的每根光纤实际上由许多家庭共享，直到相对接近这些家庭的位置，该光纤才分成每一户一根光纤。进行这种分配时，有两种光纤分布体系结构：**有源光纤网络（AON）**和**无源光纤网络（PON）**。AON本质就是交换以太网。

**PON**该技术用于Verizon的FiOS服务中。每个家庭都有一个**光纤网络端接器（ONT）**，它由专门的光纤连接到邻近的分配器。该分配器把一些家庭连接到一根共享的光纤，该光纤再连接到本地电话公司的中心局中的**光纤线路端接器（OLT）**。该OLT提供了光信号和电信号之间的转换，经过本地电话公司路由器与因特网相连。每个家庭中都有一台家庭路由器与**ONT**相连，并经过这台家庭路由器接入因特网。在**PON**体系结构中，所有从**OLT**发送到分配器的分组在分配器处复制。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQSNoxFu05NtRqyBPDPAPrI0ARSbPXsjl9ZeoP2WILyhFLg?width=997&height=450" width="997" height="450" />

5G固定式无线已经开始部署。5G固定式无线，使用波束成形技术，数据以无线方式从供应商的基站发送到家中的调制解调器，一个无线路由与该调制解调器相连。

#### 企业（家庭）接入：以太网和WIFI

在公司和大学校园等环境中，都使用局域网（LAN）将端系统连接到边缘路由器。以太网用户使用双绞线与一台以太网交换机相连，以太网交换机在与更大的因特网相连。使用以太网接入时，用户通常以100Mbps或几十Gbps的速率接入以太网交换机，服务器更有1Gbps甚至10Gbps的接入速率。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQTnu70RONAQR5O7gzYnbR86AYULQuxiw8iH9TmKt3ux_1Q?width=623&height=331" width="623" height="331" />

#### 广域无线接入：3G、LTE4G和5G

移动智能设备通过蜂窝网提供商运营的基站来发送和接受分组，与WIFI不同的是，用户仅需要位于距离基站数万米的范围内。如今4G下行可以达到60Mbps速率，5G下行可以达到20Gbps。

### 物理媒介

#### 双绞铜线

双绞线由两根绝缘的铜线组成，每根大约1mm粗，以规则的螺旋状排列着。这两根线被绞合起来，呈螺线状，减少电气干扰。通常许多双绞线捆扎在一起形成一根电缆，并在这些双绞线外面覆盖保护性防护层。**无屏蔽双绞线（UTP）**常用在建筑内的计算机网络中，速率为10Mbps~10Gbps。双绞线有不同的规格和分类。以下是主要的规格和分类：

**非屏蔽双绞线**（UTP）

1. **Cat 3**
   - **带宽**：10 Mbps
   - **频率**：16 MHz
   - **应用**：电话线、10BASE-T 以太网

2. **Cat 5**
   - **带宽**：100 Mbps
   - **频率**：100 MHz
   - **应用**：100BASE-TX、1000BASE-T

3. **Cat 5e**
   - **带宽**：1 Gbps
   - **频率**：100 MHz
   - **应用**：1000BASE-T 以太网

4. **Cat 6**
   - **带宽**：1 Gbps（10 Gbps 在短距离内）
   - **频率**：250 MHz
   - **应用**：1000BASE-T、10GBASE-T（短距离）

5. **Cat 6a**
   - **带宽**：10 Gbps
   - **频率**：500 MHz
   - **应用**：10GBASE-T 以太网

6. **Cat 7**
   - **带宽**：10 Gbps
   - **频率**：600 MHz
   - **应用**：10GBASE-T 以太网，配有屏蔽层

7. **Cat 8**
   - **带宽**：40 Gbps
   - **频率**：2000 MHz
   - **应用**：40GBASE-T 以太网，主要用于数据中心

**屏蔽双绞线**（STP 和 FTP）

- **STP（Shielded Twisted Pair）**：每对线都有屏蔽层，用于防止电磁干扰，适合工业环境。
- **FTP（Foiled Twisted Pair）**：整体有一层屏蔽层，适合需要较高抗干扰能力的环境。

**应用场景**

1. **局域网（LAN）**：常用 Cat 5e、Cat 6 及更高规格的双绞线，提供高速数据传输。
2. **电话网络**：常用 Cat 3 双绞线，满足低速数据传输需求。
3. **数据中心**：常用 Cat 6a、Cat 7 和 Cat 8 双绞线，满足超高速数据传输需求。

#### 同轴电缆

与双绞线类似，同轴电缆由两根铜导体组成，但是这两根导体是同心的而不是并行的。借助这种结构和特殊的绝缘体保护层，同轴电缆能够达到较高的数据传输速率。常用于电视天线、闭路电视、互联网和其他数据传输应用,同时提供良好的抗干扰能力。

**类型：**

1. **RG-6**：
   - **应用**：广泛用于家庭电视和有线电视连接，以及互联网接入。
   - **特点**：良好的信号传输能力，适合长距离传输。
2. **RG-59**：
   - **应用**：用于闭路电视（CCTV）和一些低频应用。
   - **特点**：适合短距离传输，信号衰减相对较大。
3. **RG-11**：
   - **应用**：用于长距离高频信号传输，如卫星电视。
   - **特点**：较粗，适合长距离和更高带宽的传输。

#### 光纤

光纤（Optical Fiber）是一种利用光信号传输数据的通信介质。它具有高带宽、低衰减和抗电磁干扰等优点，被广泛应用于现代通信网络中。光纤可以作为引导光脉冲的媒介，其中每个脉冲表示一个比特。光纤速率极快，可达数十甚至数百Gbps。

**光纤的组成结构**

光纤通常由以下几部分组成：
1. **纤芯（Core）**：传输光信号的中心部分，通常由高纯度的玻璃或塑料制成。
2. **包层（Cladding）**：包围纤芯的材料，具有比纤芯稍低的折射率，用于反射光信号回纤芯，使其沿纤芯传播。
3. **涂覆层（Coating）**：保护包层的外层，通常由树脂或塑料制成，提供机械强度和环境保护。

**光纤的种类**

1. **单模光纤（Single-Mode Fiber，SMF）**：
   - **纤芯直径**：约8-10微米
   - **波长**：1310nm 和 1550nm
   - **应用**：长距离、高速数据传输，如城域网和骨干网

2. **多模光纤（Multi-Mode Fiber，MMF）**：
   - **纤芯直径**：约50-62.5微米
   - **波长**：850nm 和 1300nm
   - **应用**：短距离数据传输，如局域网（LAN）和数据中心

3. **光载波**（OC）

光载波（Optical Carrier，OC）是同步光纤网（SONET）中的基本传输单元。它表示光信号的传输速率，以51.84 Mbit/s为基础，每增加一个单位，速率增加51.84 Mbit/s。以下是一些常见的光载波标准：

| **光载波** | **传输速率**    |
| ---------- | --------------- |
| OC-1       | 51.84 Mbit/s    |
| OC-3       | 155.52 Mbit/s   |
| OC-12      | 622.08 Mbit/s   |
| OC-24      | 1244.16 Mbit/s  |
| OC-48      | 2488.32 Mbit/s  |
| OC-192     | 9953.28 Mbit/s  |
| OC-768     | 39813.12 Mbit/s |

#### 陆地无线电信道

无线电信道用电磁频谱承载信号。它不需要安装物理线路，并具有穿透墙壁，提供与移动用户的连接以及长距离承载信号的能力，因而成为一种有吸引力的媒介。无线电信道的特性极大地依赖于传播环境和信号传播的距离。环境上的考虑取决于路径损耗和遮挡衰落（即当信号跨距离传播和绕过/通过阻碍物体时信号强度降低）、多径衰落（由于干扰对象的信号反射）以及干扰（由于其他传播或电磁信号）。

陆地无线电信道可大致划分为三类：
1. **短距离**：例如无线耳机、键盘和医疗设备，跨越1米或2米。
2. **局域**：通常跨越数十到几百米。
3. **广域**：跨越数万米，使用了如无线LAN技术和蜂窝接入技术。

#### 卫星无线电信道

1. **通信卫星的基本概念**：
   - 通信卫星用于连接地球上的两个或多个微波发射器/接收器，这些发射器/接收器被称为地面站。
   - 卫星在一个频段上接收信号，通过转发器再生信号，并在另一个频段上发射信号。

2. **同步卫星（Geostationary Satellite）**：
   - 同步卫星永久停留在地球上方的相同点上，这是通过将卫星置于地球表面上方36000公里的轨道上实现的。
   - 由于从地面站到卫星再回到地面站的距离非常远，这导致了大约280毫秒的信号传播时延。
   - 同步卫星链路能够以数百Mbps的速率运行，通常用于那些无法使用DSL或电缆因特网接入的区域。

3. **近地轨道（LEO）卫星**：
   - LEO卫星放置得非常靠近地球，并且不像同步卫星那样永久停留在地球上方的一个点。
   - 它们围绕地球旋转，类似于月亮围绕地球旋转，并且能够彼此之间以及与地面站进行通信。
   - 为了提供对某个区域的连续覆盖，需要在轨道上放置许多LEO卫星。
   - 当前有许多低轨道通信系统正在研制中，LEO卫星技术未来可能用于因特网接入。

## 网络核心

网络核心由互联网端系统的分组交换机和链路构成的网状网络。

### 分组交换

**报文**（Packet）是一种通过网络传输的基本数据单位。报文包含了发送方要传输的数据以及控制信息，用于确保数据能够正确地到达接收方。在网络应用中，端系统彼此交换报文。报文可以包含数据、音频、视频、邮件、图像等。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为分组（packet）。在源和目的地之间，每个分组都通过**通信链路**和**分组交换机**传送。交换机主要有**路由器（router）**和**链路层交换机（link-layer switch）**两类。分组以等于该链路最大传输速率的速度通过通信链路。因此

## 接口

- 在计算机网络的分层架构中，接口（Interface）通常指**不同层级之间交互的边界**，其具体归属的层级取决于上下文。
- OSI模型中，每一层通过**服务访问点（SAP, Service Access Point）**与相邻层交互，这些交互点称为接口。

### API

​		**API（Application Programming Interface，应用程序编程接口）** 是软件系统之间或不同模块之间进行交互和通信的**标准化规则和工具集**。它定义了如何请求服务、传递数据以及获取结果，类似于现实生活中的“菜单”或“说明书”。

#### 传统接口风格

- 接口统一采用 get/post 实现 所有操作。
- URL 与 资源不是 一一对应的。在 URL 中查看出，是何种操作
- 状态码统一 返回 200

| 操作         | 请求方式 | URL                                                          | 成功状态码 |
| ------------ | -------- | ------------------------------------------------------------ | ---------- |
| 查询单个用户 | GET/POST | http://127.0.0.1:8080/myweb/user/getByld?id=1http://127.0.0.1:8080/myweb/user/getByld?id=1http://127.0.0.1:8080/myweb/user/getByld?id=1 | 200        |
| 查询所有用户 | GET/POST | http://127.0.0.1:8080/myweb/user/getUserListhttp://127.0.0.1:8080/myweb/user/getUsers | 200        |
| 添加用户     | POST     | http://127.0.0.1:8080/myweb/user/addUserhttp://127.0.0.1:8080/myweb/user/saveUser | 200        |
| 修改用户     | POST     | http://127.0.0.1:8080/myweb/user/updateUserhttp://127.0.0.1:8080/myweb/user/editUser | 200        |
| 删除用户     | GET/POST | http://127.0.0.1:8080/myweb/user/deleteUser?id=1http://127.0.0.1:8080/myweb/user/delUser?id=1 | 200        |

#### RESTful

- 接口使用的方法，与 http协议的 请求方法，一一对应。
- get - 查、post - 增、put - 改、delete - 删
- URL 与 资源 一一对应！不能从 URL 中，看出是何种操作。 需要通过结合 **请求方法** 来识别何种操作
-  响应状态码 使用较为全面

| 操作         | 请求方式 | URL                                 |
| ------------ | -------- | ----------------------------------- |
| 查询单个用户 | GET      | http://127.0.0.1:8080/myweb/users/1 |
| 查询所有用户 | GET      | http://127.0.0.1:8080/myweb/users/  |
| 添加用户     | POST     | http://127.0.0.1:8080/myweb/users/1 |
| 修改用户     | PUT      | http://127.0.0.1:8080/myweb/users/1 |
| 删除用户     | DELETE   | http://127.0.0.1:8080/myweb/users/1 |

- **区别**

| 接口规范 | 请求方式             | URL                                   |
| -------- | -------------------- | ------------------------------------- |
| 传统风格 | 使用post完成增删改查 | url定义资源和操作混合                 |
| RESTful  | 遵循HTTP协议方法定义 | url仅定义一个资源，不包含对资源的操作 |

---

# **应用层**

应用层是OSI（开放系统互联）模型的第七层，也是最接近用户的一层。它提供了各种应用服务，允许软件应用程序有效地与网络通信。应用层负责处理高层协议、接口和方法，确保信息能够在应用程序之间顺利传输。

## 网络应用层原理

客户端向服务器发送请求，服务器处理请求并返回响应。客户端通常是用户与应用交互的界面，而服务器则处理数据存储和业务逻辑。网络应用依赖于多种协议来确保不同系统之间的通信，为了在不同系统之间交换数据，通常使用标准的数据格式。API提供了一组定义明确的方法，允许不同的软件系统相互通信。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQ76c1OcAPuTpVqOsI1ZHEkAcsSw-gza1pscZiMoPth4O4?width=783&height=808" width="783" height="808" />

### 网络应用体系结构

客户端-服务器体系结构是现代计算和网络应用中常见的架构模式。它将工作分成两个部分：客户端和服务器，每个部分都有特定的职责和功能。

#### 客户端-服务器体系

**客户端**是用户与应用程序交互的界面，通常是桌面应用、移动应用或Web浏览器。客户端的主要功能包括：

- **用户界面展示：** 显示数据并接收用户输入。

- **请求生成：** 生成请求并发送到服务器。

- **响应处理：** 接收和处理服务器返回的数据，并更新用户界面。

**服务器**是提供服务和处理请求的后端系统，通常运行在数据中心或云环境中。服务器的主要功能包括：

- **请求处理：** 接收客户端请求，并进行相应的处理，如查询数据库、执行业务逻辑等。
- **数据管理：** 负责存储和检索数据，保证数据的完整性和安全性。
- **响应生成：** 生成并返回响应给客户端。

**数据中心**是一个专门的设施，用于集中存储、管理和处理大量的计算机系统和相关的设备。它是现代企业和服务提供商的核心基础设施，支持各种各样的应用和服务，如云计算、存储、数据库管理和网络服务。

- **计算资源：** 包括服务器、存储设备和网络设备，用于运行各种应用程序和服务。

- **网络基础设施：** 提供高带宽、低延迟的网络连接，确保数据在服务器、存储设备和用户之间高效传输。

- **存储系统：** 用于存储大量的数据，包括磁盘阵列、固态硬盘和磁带库等。

- **电源和冷却系统：** 保证设备持续稳定运行，包括不间断电源（UPS）、备用发电机和冷却设备等。

- **安全措施：** 保护数据和设备的安全，包括防火墙、入侵检测系统（IDS）、访问控制和物理安全措施。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQOtK_PmcmbTKYNa69_cGyvAfNBufn4gKtLNv5Mz4vh5zo?width=1024" width="1024" height="auto" />

#### P2P体系

**P2P（Peer-to-Peer，点对点）**体系是一种网络架构，它允许网络中的每个节点既可以充当客户端，也可以充当服务器。这种体系结构与传统的客户端-服务器模型不同，主要特点是去中心化、节点对等和资源共享。

 P2P网络没有中央服务器，所有节点都可以平等地交换数据和提供服务。每个节点都可以贡献自己的计算资源、存储空间和带宽，从而实现资源的高效利用。由于没有单点故障，即使部分节点离线，网络仍然可以继续运行。 新节点可以自由加入或退出网络，网络规模可以灵活扩展。

**P2P网络的类型:**

- **纯P2P网络：** 没有中央服务器，所有节点完全对等，如早期的Gnutella网络。

- **混合P2P网络：** 有部分中央服务器用于节点发现和连接管理，数据传输由节点直接完成，如BitTorrent。

- **结构化P2P网络：** 使用分布式哈希表（DHT）来组织和管理节点之间的数据存储和查找，如Kademlia协议。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQSLF32AmZweTpbxrnUob10dAXpJPn4D1Spkq-iAfyWtuvg?width=382&height=441" width="382" height="441" />

### 进程通信

进行通信的实际上是**进程（process）**而不是程序。由于进程是独立的执行单元，具有独立的地址空间，因此进程通信是实现进程之间协作和资源共享的关键。

在两个不同的端系统上的进程，通过跨计算机网络交换**报文（message）**而相互通信。发送进程生成并向网络中发送报文，接受进程报文在通过报文回信。

#### 客户端和服务器进程

网络应用程序由成对的进程组成，这些进程通过网络互相发送报文。在一对进程之间通信会话场景中，发起通信的进程被标识为**客户**，在会话开始时等待联系的进程是**服务器**。在P2P中，当发起请求的对等方是**客户**，收到请求的对等方是**服务器**。

#### 进程与计算机网络之间的接口

**套接字（Sockets）**是进程与网络通信的主要接口，广泛用于各种网络应用，可以使软件接口向网络发送报文和从网络接受报文。套接字提供了一种标准化的方式，使进程可以在本地计算机或远程计算机之间进行数据传输。**应用编程接口（API，Application Programming Interface）**是一组定义明确的方法和规范，允许不同的软件系统或组件相互通信和协作。API提供了标准化的接口，使开发者能够利用现有的功能和服务，而无需了解其内部实现细节。所以套接字也称为应用编程接口。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQuywdRj52JT7tO-caqOnb-Abkd68dQVSch4hHNLs1VA3E?width=790&height=295" width="790" height="295" />

#### 进程寻址

通过IP地址和端口号的组合以确保数据能够正确传递到目标计算机上的特定进程。**IP地址（Internet Protocol Address）**是网络中每个设备的唯一标识符。**端口号**是标识计算机上特定进程或服务的编号。每个IP地址都有65536个可用端口。

### 可供应用程序使用的运输服务

#### 可靠数据传输

可靠数据传输是指在网络通信中，确保数据从发送方到接收方能够准确无误地传输，并且在传输过程中不会发生数据丢失、重复或错误的机制和方法。**容忍丢失的应用（Loss-Tolerant Applications）**是指那些在数据传输过程中能够容忍一定程度数据丢失的应用程序。当一个运输层协议不提供可靠数据传输时，由发送进程发送的某些数据可能到达不了接受进程，会被容忍丢失的应用（Loss-Tolerant Applications）所接受。

#### 吞吐量

运输层协议能够以某种特定的速率提供确保的可用吞吐量。**带宽敏感的应用（Bandwidth-Sensitive Applications）**是指那些对网络带宽要求较高，对吞吐量有要求，需要较大的数据传输速率才能正常运行的应用程序。**弹性应用（Elastic Applications）**是指能够根据需求动态调整资源分配和性能，以应对不同工作负载和用户需求变化的应用程序。

#### 定时

运输层协议也能提供定时保证。

#### 安全性

运输协议能够为应用提供多种安全性服务。

### 因特网提供的运输服务

#### TCP服务

**传输控制协议（TCP，Transmission Control Protocol）**是因特网协议套件中的一个核心协议，提供可靠、顺序且无差错的数据传输服务。

| TCP的特点 | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| 面向连接  | 在传输数据之前，发送方和接收方需要建立一个连接。这个过程通过三次握手（Three-way Handshake）完成。 |
| 可靠传输  | TCP确保数据包按序到达，并且没有数据丢失、重复或损坏。它通过确认机制、重传机制和序号来实现可靠传输。 |
| 流量控制  | 使用滑动窗口协议，TCP根据接收方的接收能力，动态调整发送方的数据发送速率，防止网络拥塞。 |
| 拥塞控制  | 采用拥塞避免算法（如慢启动、拥塞避免、快速重传和快速恢复），根据网络状况动态调整发送速率，避免网络拥塞。 |

#### 2.UDP服务

用户数据报协议（UDP，User Datagram Protocol）是一种简单、无连接的运输层协议，适用于对延迟敏感但对可靠性要求较低的应用。

| UDP的特点    | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| 无连接       | UDP是无连接的协议，发送方和接收方在传输数据之前无需建立连接。这意味着数据传输可以立即开始，减少了延迟。 |
| 不保证可靠性 | UDP不提供数据确认、重传和序号机制，因此无法保证数据包的按序到达和无丢失。数据可能会在传输过程中丢失或损坏。 |
| 面向消息     | UDP以数据报（Datagram）的形式传输，每个数据报都是一个独立的消息。UDP的每个消息大小在65507字节以内。 |
| 低开销       | 由于没有连接建立、确认和重传等机制，UDP的头部开销较小，适用于需要快速传输的场景。 |

### 万维网

**万维网（World Wide Web，简称Web或WWW）**是一个信息系统，它通过互联网将全球各地的文档和其他网络资源互连在一起，使用户能够通过超链接和URL（统一资源定位符）访问和浏览这些资源。万维网由蒂姆·伯纳斯-李（Tim Berners-Lee）于1989年在欧洲核子研究组织（CERN）发明，是互联网最广为人知的应用之一。

#### 主要组成部分

1. **超文本标记语言（HTML）**
   - **描述：** HTML是一种标记语言，用于创建网页。网页通过标签定义内容的结构和格式。

```html
<!DOCTYPE html>
<html>
<head>
    <title>示例页面</title>
</head>
<body>
    <h1>欢迎来到万维网</h1>
    <p>这是一个示例页面。</p>
</body>
</html>
```

2. 统一资源定位符（URL）

**URL**（Uniform Resource Locator，统一资源定位符）是一种用于标识互联网上资源位置的字符串。在万维网中，URL是用于访问网页、图片、视频等资源的地址。它由多个部分组成，每个部分都有其特定的功能和格式。

**URL的组成部分：**

- 协议（Scheme）：指定访问资源所使用的协议。`http`, `https`, `ftp`, `mailto` 等。
- 域名（Host）： 服务器的主机名或IP地址，标识资源所在的服务器。`www.example.com`、 `192.0.2.1`等。
- 端口号（Port）： 可选项，指定服务器的网络端口。如果省略，默认使用协议的标准端口（例如，HTTP的默认端口为80，HTTPS的默认端口为443）。
- 路径（Path）：指定资源在服务器上的具体位置。如`/index.html`、 `/images/pic.jpg`、`https://www.example.com/index.html`等。
- 查询字符串（Query）：可选项，用于传递额外参数给服务器。通常以问号`?`开始，每个参数之间用`&`分隔。如`?id=123&sort=asc`、`https://www.example.com/search?q=example`等。
- 片段标识符（Fragment）：可选项，用于标识页面中的某个部分，以井号`#`开始。如`\#section2`、 `https://www.example.com/index.html#section2`等。

3. 超文本传输协议（HTTP）

HTTP是万维网的数据通信协议，用于在客户端（如浏览器）和服务器之间传输超文本信息。用户在浏览器中输入URL，浏览器使用HTTP协议请求服务器上的资源。

## 应用层协议

应用层协议是位于OSI模型的第七层，最接近用户，它提供了一组规则和标准，确保应用程序能够在网络中通信和交换数据。应用层协议定义了数据的格式和结构，确保数据在不同系统之间能够正确地解码和解释。例如，HTTP协议定义了Web浏览器和服务器之间交换的请求和响应消息的格式。应用层协议提供了访问远程资源的机制，如文件、数据库和网络服务。FTP协议允许用户在不同计算机之间传输文件，SMTP协议则用于发送电子邮件。应用层协议管理应用程序之间的对话，包括会话的建立、维护和终止。Telnet协议允许用户远程登录到另一台计算机，并进行命令操作。应用层协议帮助识别和定位网络中的服务。DNS协议将人类可读的域名转换为IP地址，方便用户访问网站。应用层协议提供了检测和处理通信错误的机制，确保数据传输的可靠性。例如，IMAP协议在电子邮件传输过程中提供了错误检测和恢复功能。应用层协议实现了数据加密和用户认证，保护数据在传输过程中的安全性。HTTPS协议在HTTP基础上添加了SSL/TLS加密，确保Web通信的安全。

### HTTP

#### 1.概述

HTTP（Hypertext Transfer Protocol，超文本传输协议）是用于在Web浏览器和Web服务器之间传输数据的应用层协议。它是万维网（World Wide Web）的基础协议，定义了浏览器如何从服务器请求资源，以及服务器如何响应这些请求。

 HTTP使用TCP作为它的支撑运输协议（而不是UDP上运行）。当用户在浏览器中输入URL（例如`http://www.example.com`）并按下回车键时，浏览器开始发起HTTP请求。浏览器首先检查缓存中是否有目标网站的IP地址。如果没有，浏览器会向DNS服务器发送查询请求，将域名解析为IP地址。获取到服务器的IP地址后，浏览器会通过TCP（三次握手）与服务器建立连接。建立TCP连接后，浏览器向服务器发送HTTP请求。服务器接收到HTTP请求后，解析请求消息，并根据请求的资源路径和方法进行处理。服务器处理完请求后，生成HTTP响应消息并返回给客户端。浏览器接收到HTTP响应后，解析响应消息，并根据响应头的信息处理响应体。数据传输完成后，客户端和服务器通过TCP（四次挥手）释放连接。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQ4DkhPelL2RrAmJ2-znh-XAZ3nAn0t-u0DhqeKfgMhYao?width=415&height=323" width="415" height="323" />

| HTTP的特点    | 描述                                                         | 例子                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 无状态        | HTTP是无状态的协议，这意味着每个请求和响应都是独立的，与之前的请求和响应没有直接关系。为了维持会话状态，通常使用Cookie和Session等技术。 | 假设你在浏览一个在线购物网站，每次你点击商品详情页，浏览器都会向服务器发送一个独立的HTTP请求，即使你之前已经浏览过很多其他商品详情页，服务器也不知道你之前的浏览记录。为了维持你的购物车状态，服务器会使用Cookie在你的浏览器中存储一个会话ID，每次你发送请求时，浏览器会自动包含这个会话ID，服务器可以根据会话ID识别你的购物车内容。 |
| 灵活性        | HTTP协议允许传输任意类型的数据对象，由MIME类型（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）指定。 | 当你在浏览器中访问一个网站时，服务器可能会返回不同类型的内容，如HTML页面、图片、视频、CSS文件等。 |
| 请求-响应模型 | HTTP通信遵循请求-响应模型。客户端（通常是浏览器）发送HTTP请求到服务器，服务器处理请求并返回HTTP响应。一个HTTP请求包括请求行、请求头和请求体，一个HTTP响应包括状态行、响应头和响应体。 | 当你在浏览器地址栏中输入`http://www.example.com`并按下回车键时，浏览器会发送一个GET请求 |

#### 非持续连接和持续连接

HTTP的连接方式可以分为非持续连接（Non-Persistent Connection）和持续连接（Persistent Connection）。这两种连接方式在数据传输效率和资源利用方面有显著的不同。

- **往返时间**

**往返时间（Round-Trip Time，RTT）**是指从一个短分组从客户端到服务器后再返回客户端所花费的时间。RTT是衡量网络性能的关键指标，反映了数据在网络中传输的延迟情况。

**响应时间**是发送请求到接受到文件的所有时间。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQSlpthrO-TbQpctj6DLEQs9AVPPpRlaqkYoLoAfSHOW7VA?width=416&height=323" width="416" height="323" />

- **非持续连接**

在HTTP/1.0中，默认使用的是非持续连接。每次请求-响应对之间都需要建立和关闭一次TCP连接。

每次客户端发起请求时，都会建立一个新的TCP连接，当服务器返回响应后，连接立即关闭。 每次建立和关闭连接都会带来额外的开销，包括三次握手和四次挥手的延迟。频繁的连接建立和关闭导致服务器和客户端资源的浪费。

- **持续连接**

在HTTP/1.1中，默认使用的是持续连接，也称为连接重用（Connection Reuse）。在同一个TCP连接上可以发送多个请求-响应对，直到客户端或服务器明确关闭连接。

一个TCP连接可以用于多个请求-响应对，减少了连接建立和关闭的频率。通过减少连接建立和关闭的次数，降低了延迟和资源消耗。持续连接方式显著提高了数据传输效率和资源利用率。

#### HTTP报文格式

HTTP报文是客户端和服务器之间通信的数据单元。根据其发送方向，HTTP报文可以分为请求报文和响应报文。每种报文都有特定的格式和组成部分。

- **请求报文**

```http
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr



请求行（Request Line）：
GET /somedir/page.html HTTP/1.1：这表示客户端请求获取服务器上的 /somedir/page.html 页面，使用的是HTTP/1.1协议。GET方法用于请求数据，/somedir/page.html是目标资源路径，HTTP/1.1是协议版本。

请求头（Request Headers）：
Host: www.someschool.edu：指定请求的主机名为 www.someschool.edu。这对于虚拟主机很重要，因为多个域名可以共享同一个IP地址。

Connection: close：表示在完成请求后关闭连接。换句话说，服务器在发送完响应后，会断开与客户端的TCP连接。这是HTTP/1.0中的默认行为，但在HTTP/1.1中，默认使用持续连接（keep-alive）。

User-agent: Mozilla/5.0：指定客户端使用的浏览器是Mozilla 5.0。User-agent头告诉服务器客户端的软件环境，用于服务器日志记录和特定内容的响应。

Accept-language: fr：表示客户端希望接受的语言是法语（fr）。服务器可以根据这个信息返回相应语言的内容。
```

**HTTP请求头（Request Headers）**是HTTP请求报文的一部分，提供关于客户端请求的附加信息。HTTP请求头包括请求行、请求头字段（即首部行）、空行和请求体（如果有）。

**请求头字段（即首部行）**是具体的首部行，以键值对的形式出现，每行一个键值对。

**空行（Blank Line）**用于分隔请求头和请求体。在GET请求中，通常没有请求体，所以直接跟随空行后是结束的。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQ1JYD9FKJjSIMHviCKxYfNAa_PUNxme8Dxv2_xrjuBgaI?width=442&height=278" width="442" height="278" />

| HTTP请求头      | 描述                                       | 示例                                                         | 作用                                                         |
| --------------- | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Host            | 指定请求的目标主机和端口号。               | Host: www.example.com                                        | 在虚拟主机环境中，用于确定请求的目标服务器。                 |
| User-Agent      | 提供关于客户端浏览器或其他客户端的信息。   | User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 | 服务器可以根据User-Agent头的内容调整响应内容，适配不同的浏览器或设备。 |
| Accept          | 指定客户端可接受的MIME类型。               | Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 | 服务器根据Accept头选择合适的响应格式。                       |
| Accept-Language | 指定客户端可接受的语言。                   | Accept-Language: en-US,en;q=0.5                              | 服务器可以根据这个头返回相应语言的内容。                     |
| Accept-Encoding | 指定客户端可接受的内容编码（如压缩算法）。 | Accept-Encoding: gzip, deflate, br                           | 服务器可以压缩响应内容以减少传输数据量。                     |
| Connection      | 控制连接的类型。                           | Connection: keep-alive                                       | 指示服务器在完成当前请求后是否保持TCP连接打开。keep-alive表示保持连接，close表示关闭连接。 |
| Referer         | 指定请求的来源页面URL。                    | Referer: http://www.example.com/previous-page.html           | 服务器可以根据Referer头了解请求的来源。                      |
| Content-Type    | 指定请求体的媒体类型（在POST请求中使用）。 | Content-Type: application/x-www-form-urlencoded              | 服务器根据Content-Type头解析请求体中的数据。                 |
| Authorization   | 提供认证信息。                             | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            | 用于访问需要身份验证的资源。                                 |
| Cookie          | 客户端携带的Cookie数据。                   | Cookie: sessionId=abc123; theme=light                        | 用于在请求之间维持会话状态                                   |

> [important]
>
> **常见Content-type**
>
> ###### 作用：指定 请求体的数据类型。
>
> - `text/plain`：纯文本格式；
> - `text/html`：HTML格式；
> - `text/css`：Cascading Style Sheets；
> - `text/javascript`：JavaScript代码；
> - `application/json`：JSON格式数据；
> - `application/xml`：XML格式数据；
> - `application/octet-stream`：二进制流数据；
> - `image/jpeg`：JPEG格式图片；
> - `image/gif`：GIF格式图片；
> - `image/png`：PNG格式图片；
> - `audio/mpeg`：MP3格式音频；
> - `video/mp4`：MP4格式视频；
> - `multipart/form-data`：表单数据；
> - `application/x-www-form-urlencoded`：URL编码表单数据；

- **HTTP响应报文**

```http
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ...)


状态行（Status Line）
HTTP/1.1 200 OK
HTTP版本： 使用的是HTTP/1.1版本。
状态码： 200，表示请求成功。
状态描述： OK，表示请求已成功处理。


响应头部（Response Headers）
Connection: close
描述： 指示服务器在完成请求后关闭连接。
作用： 告诉客户端，这个响应之后的TCP连接将被关闭，不会保持打开状态。

Date: Tue, 18 Aug 2015 15:44:04 GMT
描述： 服务器响应的日期和时间。
作用： 提供服务器生成响应的时间戳，按照GMT格式。

Server: Apache/2.2.3 (CentOS)
描述： 服务器的类型和版本。
作用： 告知客户端服务器使用的是Apache 2.2.3版本，并且运行在CentOS操作系统上。

Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
描述： 资源最后修改的日期和时间。
作用： 提供资源的上次修改时间，客户端可以使用此信息进行缓存验证。

Content-Length: 6821
描述： 响应体的长度（字节数）。
作用： 告诉客户端响应体的大小，以便于正确处理数据。

Content-Type: text/html
描述： 响应体的媒体类型。
作用： 指定响应的内容类型为HTML文档，客户端可以根据此信息决定如何显示内容。


响应体（Response Body）
(data data data data data ...)
描述： 服务器返回的实际数据。
作用： 这是实际的HTML内容或其他数据类型，客户端将根据内容类型来处理和显示数据。
```

HTTP的**状态行（Status Line）**是HTTP响应报文中的第一行，用于表示服务器对客户端请求的处理结果。

**响应头部（Response Headers）**是服务器在响应报文中发送给客户端的头字段，提供关于响应的附加信息。响应头部以键值对的形式出现，每行一个键值对。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQSIjmc2cIQGSaQLazzqEeOlAb9XpG9R0x6pmPUProANndg?width=426&height=260" width="426" height="260" />

| HTTP响应头     | 描述                           | 示例                                           | 作用                                                         |
| -------------- | ------------------------------ | ---------------------------------------------- | ------------------------------------------------------------ |
| Date           | 指定响应生成的日期和时间。     | Date: Mon, 13 Jan 2025 16:41:00 GMT            | 提供服务器生成响应的时间戳，按照GMT格式。                    |
| Server         | 指定服务器的软件信息。         | Server: Apache/2.4.41 (Ubuntu)                 | 告知客户端服务器使用的软件类型和版本。                       |
| Content-Type   | 指定响应体的媒体类型和字符集。 | Content-Type: text/html; charset=UTF-8         | 告诉客户端响应内容的类型和编码格式，以便正确解析和显示内容。 |
| Content-Length | 指定响应体的长度（字节数）。   | Content-Length: 6821                           | 告诉客户端响应体的大小，便于正确处理数据。                   |
| Last-Modified  | 指定资源最后修改的日期和时间。 | Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT   | 提供资源的上次修改时间，帮助客户端进行缓存验证。             |
| Connection     | 控制连接的类型。               | Connection: keep-alive                         | 指示服务器在完成当前请求后是否保持TCP连接打开。keep-alive表示保持连接，close表示关闭连接。 |
| ETag           | 提供资源的特定版本标识。       | ETag: "686897696a7c876b7e"                     | 用于缓存验证，帮助客户端判断资源是否发生变化。               |
| Cache-Control  | 指定缓存机制。                 | Cache-Control: no-cache                        | 控制缓存行为，如是否缓存、缓存的最大时间等。                 |
| Expires        | 指定响应过期的日期和时间。     | Expires: Wed, 21 Oct 2015 07:28:00 GMT         | 设置资源的过期时间，帮助客户端管理缓存。                     |
| Set-Cookie     | 向客户端发送Cookie数据。       | Set-Cookie: sessionId=abc123; Path=/; HttpOnly | 用于在客户端设置Cookie，维持会话状态或保存用户偏好。         |

### cookie用户与服务器的交互

Cookies是由网站存储在用户浏览器上的小文本文件，用于保存和追踪用户的状态信息。它们在HTTP协议无状态的情况下，帮助Web应用保持会话状态、个性化用户体验和跟踪用户行为。

#### **什么是Cookie？**

Cookie是存储在用户设备上的一小段文本信息，由服务器生成并发送到浏览器。浏览器会在后续请求中携带这些Cookie，发送回服务器，以便服务器识别用户和维护会话状态。

#### Cookie的结构

```http
Set-Cookie: sessionId=abc123; Domain=example.com; Path=/; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Secure; HttpOnly
```

| 字段                | 描述                               |
| ------------------- | ---------------------------------- |
| 名称（Name）        | Cookie的键名称。                   |
| 值（Value）         | Cookie的值。                       |
| 域（Domain）        | Cookie所属的域名。                 |
| 路径（Path）        | Cookie生效的路径。                 |
| 过期时间（Expires） | Cookie的有效期，指定日期和时间。   |
| 最大寿命（Max-Age） | Cookie的有效期，以秒为单位。       |
| 安全标志（Secure）  | 指示Cookie仅通过HTTPS传输。        |
| HttpOnly标志        | 指示Cookie不能通过JavaScript访问。 |

#### Cookie的类型

- **会话Cookie（Session Cookies）：**
  - **描述：** 仅在浏览器会话期间有效，浏览器关闭后会被自动删除。
  - **用途：** 常用于临时信息的存储，如购物车内容、登录状态等。
- **持久Cookie（Persistent Cookies）：**
  - **描述：** 具有指定的过期时间，在浏览器关闭后仍然保留，直到到达过期时间。
  - **用途：** 用于长期保存用户偏好、登录凭证等。
- **安全Cookie（Secure Cookies）：**
  - **描述：** 仅通过HTTPS传输，确保数据在传输过程中被加密。
  - **用途：** 用于存储敏感信息，如会话ID和认证令牌。
- **HttpOnly Cookie：**
  - **描述：** 仅供服务器访问，客户端脚本（如JavaScript）无法读取，防止XSS攻击。
  - **用途：** 用于增加安全性，防止客户端脚本窃取Cookie信息。

#### HTTP使用Cookie的过程

1. **用户访问登录页面**

   用户在浏览器中输入网站的URL，浏览器发送HTTP GET请求到服务器，请求登录页面。

   ```http
   GET /login HTTP/1.1
   Host: www.example.com
   ```

   服务器返回登录页面的HTML。

   ```http
   HTTP/1.1 200 OK
   Content-Type: text/html; charset=UTF-8

   <html>
   <head>
       <title>Login Page</title>
   </head>
   <body>
       <form action="/authenticate" method="POST">
           Username: <input type="text" name="username"><br>
           Password: <input type="password" name="password"><br>
           <input type="submit" value="Login">
       </form>
   </body>
   </html>
   ```

2. **用户提交登录信息**

   用户在登录页面输入用户名和密码，并提交表单。浏览器发送HTTP POST请求到服务器，包含登录信息。

   ```http
   POST /authenticate HTTP/1.1
   Host: www.example.com
   Content-Type: application/x-www-form-urlencoded
   Content-Length: 39

   username=user1&password=pass123
   ```

3. **服务器验证登录信息并设置Cookie**

   服务器验证用户的登录信息。如果验证成功，服务器生成会话ID，并在响应中设置Cookie，将会话ID发送给浏览器。

   ```http
   HTTP/1.1 200 OK
   Set-Cookie: sessionId=abc123; Path=/; HttpOnly
   Content-Type: text/html; charset=UTF-8

   <html>
   <head>
       <title>Welcome Page</title>
   </head>
   <body>
       <h1>Welcome, user1!</h1>
   </body>
   </html>
   ```

4. **浏览器存储Cookie**

   浏览器接收到服务器的响应后，存储Cookie**（sessionId=abc123）**。由于设置了HttpOnly标志，客户端脚本无法访问此Cookie。

5. **用户访问其他页面**

   用户访问网站的其他页面。浏览器在每次请求中都会携带存储的Cookie，发送给服务器以维持会话状态。

   ```http
   GET /dashboard HTTP/1.1
   Host: www.example.com
   Cookie: sessionId=abc123
   ```

   服务器根据接收到的Cookie识别用户会话，并返回相应的页面。

   ```http
   HTTP/1.1 200 OK
   Content-Type: text/html; charset=UTF-8

   <html>
   <head>
       <title>Dashboard</title>
   </head>
   <body>
       <h1>User Dashboard</h1>
       <p>Welcome back, user1!</p>
   </body>
   </html>
   ```

6. **用户登出**

   用户点击登出按钮，浏览器发送HTTP GET请求到服务器请求登出。

   ```http
   GET /logout HTTP/1.1
   Host: www.example.com
   Cookie: sessionId=abc123
   ```

   服务器处理登出请求，删除会话并使Cookie失效。

   ```http
   HTTP/1.1 200 OK
   Set-Cookie: sessionId=deleted; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT
   Content-Type: text/html; charset=UTF-8
   
   <html>
   <head>
       <title>Logged Out</title>
   </head>
   <body>
       <h1>You have been logged out.</h1>
   </body>
   </html>
   ```

<img src="https://1drv.ms/i/c/a643854c1477e063/IQST37sbT_KNTZxm3HB4TaWhAbdQQvmf4MeQYncbWPutL3w?width=673&height=577" width="673" height="577" />

### session

客户端访问服务器时，服务器会将信息以某种形式记录在服务器上，以保持用户会话的状态。每个客户
端都有自己的一个Session会话，通常存储在服务器端，并由一个唯一的会话标识符（Session ID）进行
标识。

Session会话中可以用于存储用户登录之后的信息，比如用户ID、登录状态等。这样，当用户在应用程序
的页面之间跳转时，存储在Session会话中的这些信息就不会丢失，而是在整个用户会话期间一直存在。

**Session实现会话管理的一般过程：**

- 用户登录：当用户成功登录时，应用程序在服务器端创建一个唯一的Session. ID，并将该Session ID存储在Cookie或通过其他机制发送到客户端浏览器。
- 会话状态存储：应用程序将用户的会话状态存储在服务器端，可以包括身份验证信息、购物车内容、页面浏览记录等。
- 会话状态验证：当用户与应用程序进行交互时，浏览器会自动发送存储的SessionID。应用程序通过验证SessionID来确认用户的身份和会话状态。
- 会话管理：应用程序可以使用Session ID来管理会话。例如，当用户添加商品到购物车时，应用程序可以使用Session ID来识别用户的购物车，并保存相应的状态信息。

### token

​		Token通常指的是一种用于身份验证和授权的机制，用于验证用户是否具有访问特定资源或执行特定操作的权限。
​		在传统的基于Session的鉴权方式中，用户在登录成功后会获得一个Session ID，并将其存储在Cookie中。当用户发送后续请求时，服务器会验证Cookie中的Session ID是否与服务器端存储的SessionID匹配，以确定用户是否合法。但是，这种方式需要在服务器端存储大量的Session信息，增加了服务器的负载和数据库的负担。
​		相比之下，Token鉴权更加方便和简单。在用户登录成功后，服务器会生成一个Token并将其返回给客户端。客户端在后续请求中将Token放在请求头中，作为身份验证的标识。服务器端在接收到请求后，将根据Token进行身份验证，判断用户是否有权访问请求的资源或执行特定的操作。
**一般来说，Token鉴权的实现方式包括以下步骤：**

1. 客户端向服务器端发送用户名和密码进行身份验证。
2. 服务器端验证用户名和密码是否正确，并生成一个Token。
3. 服务器将Token返回给客户端，客户端将其暂时保存在本地。
4. 客户端在后续每次发送请求时，将Token放在请求头中。

服务器端接收到请求后，验证请求头中的Token是否与服务器端存储的Token匹配，如果匹配则请求成功，否则失败。为了确保安全性，Token的生成应该是不可预测的，并且应该定期更换。此外，服务器应该使用加密算法对Token进行加密存储和传输，以避免被恶意攻击者获取和利用。

### 常见状态码分类

| **状态码** | 状态信息               | 说明                                                         |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| **100**    | Continue               | 请求者应当继续提出请求。这表示服务器已初步接受了请求，客户端应继续发送请求的其余部分 |
| **101**    | Switching Protocols    | 服务器根据客户端的请求切换协议。例如，升级到WebSocket协议    |
| **200**    | OK                     | 请求成功。这是最常见的状态码，表示请求已成功被服务器处理     |
| **201**    | Created                | 请求成功并且服务器创建了新的资源                             |
| **202**    | Accepted               | 服务器已接受请求，但尚未处理                                 |
| **204**    | No Content             | 服务器成功处理了请求，但没有返回任何内容                     |
| **301**    | Moved Permanently      | 请求的资源已永久移动到新的URL，应使用新的URL进行访问         |
| **304**    | Not Modified           | 客户端缓存的资源是最新的，无需再次发送请求到服务器           |
| **400**    | Bad Request            | 客户端请求的语法错误，服务器无法理解                         |
| **401**    | Unauthorized           | 请求需要身份验证                                             |
| **403**    | Forbidden              | 服务器理解请求，但是拒绝执行它                               |
| **404**    | Not Found              | 服务器无法找到请求的资源                                     |
| **405**    | Method Not Allowed     | 请求中使用的HTTP方法不被允许                                 |
| **415**    | Unsupported Media Type | 请求的格式不受请求页面的支持                                 |
| **500**    | Internal Server Error  | 服务器遇到了一个未曾预料的情况，导致其无法完成对请求的处理   |
| **501**    | Not Implemented        | 服务器不支持当前请求所需要的某个功能                         |
| **502**    | Bad Gateway            | 作为网关或代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应 |
| **503**    | Service Unavailable    | 由于临时的服务器维护或者过载，服务器当前无法处理请求         |
| **504**    | Gateway Timeout        | 作为网关或者代理工作的服务器没有从上游服务器收到及时的响应   |

> [info]
>
> **概念**
>
> - 一定位于 http响应协议的，第一行。格式：协议版本 (空格) 状态码 (空格) 状态码描述
>
> **状态码分类**
>
> - **1xx**：指示信息
> - **2xx**：成功
> - **3xx**：重定向
> - **4xx**：客户端错误
> - **5xx**：服务端错误

### Web缓存

**Web缓存**是一种提高Web应用程序性能和减少服务器负载的技术。它通过在客户端或中间代理服务器上存储资源的副本，减少了向原始服务器请求资源的频率，从而加快了页面加载速度。

 **内容分发网络（Content Delivery Network, CDN）**是一种分布式服务器系统，用于高效地传输网站和应用的内容给全球各地的用户。通过将内容存储在多个地理位置的缓存服务器上，CDN显著提高了内容的访问速度和可用性，同时减少了原始服务器的负载。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQRHxodGipz9Q79eG82aXEXFAa6x4dWIxTA_fEEKvsj9SIk?width=477&height=300" width="477" height="300" />

**条件GET**是HTTP协议中的一种请求机制，允许客户端在一定条件下请求服务器上的资源。这种机制主要用于减少不必要的数据传输和提高缓存效率。条件GET请求通常会附带一些头字段，服务器根据这些头字段的值来决定是否返回完整的资源或仅返回状态码。条件GET请求的基本思路是让客户端在请求资源时，附带一些条件信息，这些条件信息通常是从先前获取的资源中提取的。服务器接收到条件GET请求后，会根据这些条件信息判断资源是否发生变化，然后做出相应的响应：

1. 如果资源没有变化，服务器返回 `304 Not Modified` 状态码，不返回资源内容。
2. 如果资源发生变化，服务器返回 `200 OK` 状态码，并返回最新的资源内容。

假设用户第一次访问网站，浏览器发送普通GET请求并接收资源：
```http
GET /index.html HTTP/1.1
Host: www.example.com

HTTP/1.1 200 OK
Content-Type: text/html
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
ETag: "686897696a7c876b7e"

<html>...</html>
```
浏览器接收到资源，并缓存响应头中的 `Last-Modified` 和 `ETag` 信息。

后续访问时，浏览器发送条件GET请求：
```http
GET /index.html HTTP/1.1
Host: www.example.com
If-Modified-Since: Tue, 18 Aug 2015 15:11:03 GMT
If-None-Match: "686897696a7c876b7e"
```
服务器检查资源是否自指定时间以来已被修改：

1. **资源未修改**
   ```http
   HTTP/1.1 304 Not Modified
   ```
   服务器返回 `304 Not Modified` 状态码，浏览器从缓存中加载资源，减少了数据传输。

2. **资源已修改**
   ```http
   HTTP/1.1 200 OK
   Content-Type: text/html
   Last-Modified: Tue, 18 Aug 2015 16:30:00 GMT
   ETag: "9b3848cae8e876b7e"
   
   <html>...</html>
   ```
   服务器返回最新的资源内容，浏览器更新缓存。

### HTTP/2

**HTTP/2**是HTTP协议的第二个主要版本，旨在提高Web性能，减少延迟和带宽消耗。

**HOL阻塞**（Head-of-Line Blocking，队首阻塞）是一种在缓存式通信网络交换中常见的现象。其交换结构通常由缓存式FIFO输入端、交换结构（Switch Fabric）和FIFO输出端构成。HOL阻塞发生在相同的输入端口上到达的分组报文被指向不同的输出端口时。例如，如果输入队列1和3同时有分组报文要转发到输出队列4，而Switch Fabric仲裁选择输入队列3进行数据转发，那么输入队列1就必须等待，即使输出队列3空闲。HTTP/1.1为了解决HOL阻塞选择使用多条并行的TCP连接。HTTP/2主要目的就是为了减少其数量。

| 特性       | 描述                                                         | 优点                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 二进制协议 | HTTP/2使用二进制格式传输数据，而不是HTTP/1.1的文本格式。     | 二进制格式更易于解析，减少了传输和解析的开销，提高了传输效率。 |
| 多路复用   | 多路复用允许在一个TCP连接上并行发送多个请求和响应，而无需为每个请求创建单独的连接。 | 减少了连接建立的开销，避免了HTTP/1.1中存在的队头阻塞问题，提高了传输速度。 |
| 头部压缩   | HTTP/2引入了HPACK头部压缩算法，通过静态和动态表存储字段，减少头部信息的冗余传输。 | 减少了头部信息的传输大小，降低了带宽消耗。                   |
| 服务器推送 | 服务器推送允许服务器在客户端请求之前主动向客户端发送资源。   | 提高了页面加载速度，减少了延迟。例如，当客户端请求HTML页面时，服务器可以主动推送相关的CSS和JavaScript文件。 |
| 流量控制   | HTTP/2支持细粒度的流量控制，可以对每个流进行独立的流量管理。 | 提高了资源利用率和传输的公平性。                             |
| 优先级     | 客户端可以为请求分配优先级，以确定资源加载的顺序。           | 提高了关键资源的加载速度，优化了页面的渲染性能。             |

#### 成帧（Framing）

HTTP/2引入了一种新的数据传输机制，称为**“成帧”（Framing）**。成帧机制通过将数据报文分解为更小的**帧**进行传输，并且在相同TCP连接上交错发送报文请求和响应报文，使得通信更加高效和灵活。

例如一个web页面，由一个视频和多个图片组成。打开网页时首先会将视频和图片分成许多个帧，然后会传输视频的数据帧，在传输图像的数据帧，在传输视频的数据帧，交替传输。因为视频的帧要比图像的帧多的多，所以图像会先加载出来，而不是等视频完全加载完后才显示图像。

| 帧类型          | 描述                             | 用途                                                       |
| --------------- | -------------------------------- | ---------------------------------------------------------- |
| DATA帧          | 传输HTTP请求或响应的实际数据。   | 用于将数据内容分成若干个数据帧进行传输。                   |
| HEADERS帧       | 传输HTTP头部信息。               | 携带请求或响应的头部字段。                                 |
| PRIORITY帧      | 指定流的优先级。                 | 控制流的处理顺序，优化资源分配。                           |
| RST_STREAM帧    | 重置流。                         | 中止特定流的传输，通常用于取消请求或指示错误。             |
| SETTINGS帧      | 配置连接参数。                   | 交换连接配置，如最大并发流数量、流量控制参数等。           |
| PUSH_PROMISE帧  | 服务器推送资源。                 | 服务器主动向客户端推送资源，提前传输客户端可能需要的资源。 |
| PING帧          | 测试连接的可达性。               | 确认连接是否仍然有效，通常用于保活机制。                   |
| GOAWAY帧        | 终止连接。                       | 通知对方即将关闭连接，通常用于服务器维护或升级。           |
| WINDOW_UPDATE帧 | 更新流量控制窗口大小。           | 控制流量，防止发送方发送过多的数据。                       |
| CONTINUATION帧  | 继续传输HEADERS帧的头部块。      | 在HEADERS帧内容过多时分片传输。                            |
| ALTSVC帧        | 通知客户端可以使用替代服务端点。 | 提供替代服务地址，提高服务可用性。                         |
| ORIGIN帧        | 通知客户端连接的原始服务器信息。 | 支持多宿主环境下的优化，告知客户端服务器的原始信息。       |

在HTTP/2中，**成帧子层（Framing Layer）**是一个关键的子层，负责将数据报文分解为更小的帧进行传输，并在客户端和服务器之间进行高效的通信。

成帧子层通过客户端或服务器将要传输的数据分割为多个帧。为每个帧添加必要的头部信息，包括帧类型、流ID、长度等。客户端或服务器按照顺序将帧发送到对方。对方接收到帧后，根据流ID和顺序，将帧重新组装为完整的数据。成帧子层也会对这些帧进行二进制编码。

#### 流（Stream）

在HTTP/2中，**流（Stream）** 是一种独立的、双向的字节流，客户端和服务器可以在一个TCP连接中并行地发送和接收多个流。每个流都是由多个帧（Frame）组成的序列，并且每个流都有一个唯一的标识符（Stream ID）。

| 流状态                | 描述                                               | 示例                                                   |
| --------------------- | -------------------------------------------------- | ------------------------------------------------------ |
| IDLE（闲置）          | 流处于初始状态，还没有任何帧被传输。               |                                                        |
| OPEN（打开）          | 流正在传输数据，客户端和服务器都可以发送帧。       |                                                        |
| HALF-CLOSED（半关闭） | 流的一个方向已经关闭，但另一个方向仍可以传输数据。 | 客户端发送完请求后关闭发送方向，但服务器仍在发送响应。 |
| CLOSED（关闭）        | 流的两个方向都已经关闭，不再传输任何数据。         |                                                        |
| RESERVED（保留）      | 流被保留以便在将来使用。                           |                                                        |

| 特性     | 描述                                                 | 示例                                                       |
| -------- | ---------------------------------------------------- | ---------------------------------------------------------- |
| 唯一标识 | 每个流都有一个唯一的流ID，用于区分不同的流。         | 流ID为1的流与流ID为2的流是不同的独立流。                   |
| 双向通信 | 流可以同时在客户端和服务器之间进行双向通信。         | 客户端发送请求帧，服务器可以在同一流上发送响应帧。         |
| 多路复用 | 多个流可以并行地在一个TCP连接上传输，不会相互阻塞。  | 客户端可以同时发送多个请求，服务器也可以同时返回多个响应。 |
| 优先级   | 客户端可以为每个流分配优先级，以确定资源加载的顺序。 | 优先加载关键资源如CSS和JavaScript文件。                    |
| 流量控制 | HTTP/2支持流量控制，可以对每个流进行独立的流量管理。 | 限制每个流的数据传输速率，避免拥塞。                       |

#### 连接（Connection）

在HTTP/2中，**连接（Connection）**是客户端和服务器之间通信的基础。HTTP/2通过一个**长连接（Long-lived Connection）**进行多个并行的流（Stream）传输，这种机制显著提高了通信效率和性能。

| 特性       | 描述                                                 | 优点                                                         |
| ---------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 长连接     | HTTP/2使用单个持久的TCP连接来传输多个请求和响应。    | 减少了重复建立连接的延迟，提高了传输效率。                   |
| 多路复用   | 在同一个TCP连接上，多个流可以并行传输。              | 消除了HTTP/1.1中的队头阻塞问题，提高了连接的利用率和传输速度。 |
| 流量控制   | 对每个流进行独立的流量控制。                         | 提高了资源的公平分配和利用率。                               |
| 优先级     | 客户端可以为每个流分配优先级，以决定资源加载的顺序。 | 优先传输关键资源，提高页面加载的整体性能。                   |
| 头部压缩   | 使用HPACK算法对头部信息进行压缩。                    | 降低了带宽消耗，减少了数据传输量。                           |
| 连接管理   | HTTP/2的设置帧（SETTINGS帧）用于配置连接参数。       | 如最大并发流数量、流量控制窗口等，提高了连接的配置灵活性。   |
| PING帧     | 客户端和服务器通过PING帧测试连接的可达性。           | 确保连接的稳定性和可用性。                                   |
| 服务器推送 | 允许服务器在客户端请求之前主动向客户端发送资源。     | 提高了页面加载速度，减少了延迟。                             |

#### 传输过程

在HTTP/2中，帧的交替传输通过多路复用机制实现，使得在一个TCP连接中可以同时传输多个流的数据。以下是一个包含视频和8个小对象的网页如何通过HTTP/2帧进行传输的示例：

1. **视频请求（流ID 1）**
   
   - 客户端发送HEADERS帧，请求视频内容。
     ```http
     +-----------------------------------------------+
     | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 1 |
     +-----------------------------------------------+
     | :method = GET                                 |
     | :path = /video.mp4                            |
     | :scheme = https                               |
     | :authority = www.example.com                  |
     +-----------------------------------------------+
     ```
   
2. **视频响应（流ID 1）**
   
   - 服务器响应HEADERS帧，传输视频内容。
     ```http
     +-----------------------------------------------+
     | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 1 |
     +-----------------------------------------------+
     | :status = 200                                 |
     | content-type = video/mp4                      |
     +-----------------------------------------------+
     ```
   - 服务器发送多个DATA帧传输视频内容。
     ```http
     +-----------------------------------------------+
     | Length: ... | Type: DATA | Flags: 0 | Stream ID: 1 |
     +-----------------------------------------------+
     | [视频数据块1]                                  |
     +-----------------------------------------------+
     
     +-----------------------------------------------+
     | Length: ... | Type: DATA | Flags: 0 | Stream ID: 1 |
     +-----------------------------------------------+
     | [视频数据块2]                                  |
     +-----------------------------------------------+
     ```
   
3. **小对象请求（流ID 2-9）**
   - 客户端并行发送HEADERS帧，请求8个小对象。
     ```http
     +-----------------------------------------------+
     | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 2 |
     +-----------------------------------------------+
     | :method = GET                                 |
     | :path = /object1.png                          |
     | :scheme = https                               |
     | :authority = www.example.com                  |
     +-----------------------------------------------+
     
     +-----------------------------------------------+
     | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 3 |
     +-----------------------------------------------+
     | :method = GET                                 |
     | :path = /object2.png                          |
     | :scheme = https                               |
     | :authority = www.example.com                  |
     +-----------------------------------------------+
     
     （同样发送HEADERS帧请求object3.png到object8.png，流ID分别为4到9）
     ```

4. **小对象响应（流ID 2-9）**
   - 服务器并行响应HEADERS帧，传输8个小对象内容。
     ```http
     +-----------------------------------------------+
     | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 2 |
     +-----------------------------------------------+
     | :status = 200                                 |
     | content-type = image/png                      |
     +-----------------------------------------------+
     
     +-----------------------------------------------+
     | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 3 |
     +-----------------------------------------------+
     | :status = 200                                 |
     | content-type = image/png                      |
     +-----------------------------------------------+
     
     （同样响应object3.png到object8.png，流ID分别为4到9）
     ```
   - 服务器发送DATA帧传输每个小对象内容。
     ```http
     +-----------------------------------------------+
     | Length: ... | Type: DATA | Flags: END_STREAM | Stream ID: 2 |
     +-----------------------------------------------+
     | [object1.png数据]                              |
     +-----------------------------------------------+
     
     +-----------------------------------------------+
     | Length: ... | Type: DATA | Flags: END_STREAM | Stream ID: 3 |
     +-----------------------------------------------+
     | [object2.png数据]                              |
     +-----------------------------------------------+
     
     （同样传输object3.png到object8.png，流ID分别为4到9）
     ```

#### 响应报文的优先次序

在HTTP/2中，响应报文的优先次序由客户端通过**设置帧（PRIORITY帧）**来指定。优先级机制允许客户端为每个流分配一个优先级，从而决定服务器处理和传输响应的顺序。

HTTP/2使用一个带权重的**优先级树**来表示流的优先关系。每个流都有一个父节点和**权重（0-256）**，根节点是隐式的，ID为0。数字越大权重越高。

#### 服务器推送（Server Push）

HTTP/2引入了一项称为**服务器推送**（Server Push）的新特性，允许服务器在客户端请求之前主动向客户端发送资源。这种机制可以显著减少页面加载时间，提高用户体验。

1. 客户端请求资源

- **描述：** 客户端向服务器发送一个HEADERS帧，请求某个网页资源。
- **示例：**
  ```http
  +-----------------------------------------------+
  | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 1 |
  +-----------------------------------------------+
  | :method = GET                                 |
  | :path = /index.html                           |
  | :scheme = https                               |
  | :authority = www.example.com                  |
  +-----------------------------------------------+
  ```

2. 服务器响应请求

- **描述：** 服务器解析请求，准备响应。在响应的过程中，服务器决定哪些资源是客户端可能需要的，并提前进行推送。
- **示例：** 服务器发送HEADERS帧和DATA帧，传输网页内容。
  ```http
  +-----------------------------------------------+
  | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 1 |
  +-----------------------------------------------+
  | :status = 200                                 |
  | content-type = text/html                      |
  +-----------------------------------------------+
  ```

3. 服务器发送PUSH_PROMISE帧

- **描述：** 服务器通过发送PUSH_PROMISE帧通知客户端即将推送的资源。这些帧包含即将推送资源的元数据（例如：路径、方法）。
- **示例：**
  ```http
  +-----------------------------------------------+
  | Length: ... | Type: PUSH_PROMISE | Flags: END_HEADERS | Stream ID: 1 |
  +-----------------------------------------------+
  | Promised Stream ID: 2                         |
  | :method = GET                                 |
  | :path = /style.css                            |
  | :scheme = https                               |
  | :authority = www.example.com                  |
  +-----------------------------------------------+
  ```

4. 服务器推送资源

- **描述：** 服务器通过Promised Stream ID创建新的流，发送HEADERS帧和DATA帧推送资源。
- **示例：**
  ```http
  +-----------------------------------------------+
  | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 2 |
  +-----------------------------------------------+
  | :status = 200                                 |
  | content-type = text/css                       |
  +-----------------------------------------------+
  
  +-----------------------------------------------+
  | Length: ... | Type: DATA | Flags: END_STREAM | Stream ID: 2 |
  +-----------------------------------------------+
  | [CSS内容]                                     |
  +-----------------------------------------------+
  ```

5. 客户端处理推送资源

- **描述：** 客户端收到PUSH_PROMISE帧后，知道即将接收到指定的资源。客户端可以选择接受这些推送资源或通过发送RST_STREAM帧拒绝推送。
- **示例：**
  ```http
  +-----------------------------------------------+
  | Length: ... | Type: RST_STREAM | Flags: 0 | Stream ID: 2 |
  +-----------------------------------------------+
  | Error Code: CANCEL                            |
  +-----------------------------------------------+
  ```

### HTTP/3

**HTTP/3**是HTTP/2的继任者，主要基于新的传输协议**QUIC**。QUIC旨在解决HTTP/2中的一些问题，如队头阻塞（Head-of-Line Blocking）和握手延迟。

| 特点             | 描述                                                         | 优点                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基于QUIC协议     | QUIC是一种新的传输层协议，基于UDP而不是TCP。                 | 减少了握手延迟，提高了连接建立速度。                         |
| 解决队头阻塞问题 | 在HTTP/2中，由于TCP的有序传输特性，一个丢失的数据包会导致所有后续数据包的延迟。 | QUIC通过独立的流来处理数据传输，避免了队头阻塞问题，提高了多路复用效率。 |
| 更快的连接建立   | QUIC在连接建立时不需要进行三次握手，而是通过0-RTT或1-RTT来加速连接建立。 | 减少了连接建立的时间，提高了整体性能。                       |
| 连接迁移         | QUIC支持连接迁移，即在网络条件变化时可以保持连接而不需要重新建立。 | 提高了连接的鲁棒性和稳定性。                                 |

#### 1.HTTP/3的工作原理

1. **客户端请求资源**
   - 客户端通过QUIC协议向服务器发送请求。
2. **服务器响应请求**
   - 服务器通过QUIC协议响应客户端的请求，同时可以通过PUSH_PROMISE帧主动推送资源。
3. **数据传输**
   - 数据通过QUIC的独立流进行传输，避免了队头阻塞问题。
4. **连接管理**
   - QUIC自动处理连接的建立、维护和迁移，提高了连接的稳定性和性能。

#### 2.QUIC协议

**QUIC**（Quick UDP Internet Connections）是一种新的传输层协议，由Google开发，旨在提高网络传输的性能和效率。QUIC基于UDP（User Datagram Protocol），并结合了TCP（Transmission Control Protocol）的一些特性，同时引入了新的优化措施，使其在传输速度、安全性和可靠性方面表现出色。以下是QUIC协议的详细介绍：

**主要特点**

1. **基于UDP**
   - **描述：** QUIC使用UDP作为其底层传输协议，而不是传统的TCP。
   - **优点：** 减少了连接建立的延迟，提高了数据传输的灵活性和速度。

2. **集成TLS加密**
   - **描述：** QUIC协议在传输层集成了TLS（Transport Layer Security）加密，确保数据的安全传输。
   - **优点：** 提高了数据传输的安全性，简化了加密过程。

3. **快速连接建立**
   - **描述：** QUIC协议支持0-RTT和1-RTT连接建立，显著减少了连接建立的时间。
   - **优点：** 提高了网络性能，特别是在高延迟网络环境中。

4. **多路复用**
   - **描述：** QUIC协议支持在单个连接上并行传输多个流，避免了TCP中的队头阻塞问题。
   - **优点：** 提高了传输效率和资源利用率。

5. **连接迁移**
   - **描述：** QUIC协议支持连接迁移，即在网络条件变化时可以保持连接而不需要重新建立。
   - **优点：** 提高了连接的稳定性和鲁棒性。

**工作原理**

1. **连接建立**
   - 客户端向服务器发送QUIC连接请求，使用0-RTT或1-RTT加速连接建立。
   - 服务器响应连接请求，建立安全的传输通道。

2. **数据传输**
   - 数据通过QUIC的独立流进行传输，避免了TCP中的队头阻塞问题。
   - QUIC协议在传输过程中使用TLS加密，确保数据的安全性。

3. **连接管理**
   - QUIC协议自动处理连接的维护和迁移，确保在网络条件变化时连接的稳定性。

**示例**

假设客户端请求一个网页资源，整个过程涉及到多个步骤：

1. **客户端发送请求**
   ```http
   GET /index.html HTTP/3
   Host: www.example.com
   ```

2. **服务器响应请求**
   ```http
   +-----------------------------------------------+
   | Length: ... | Type: HEADERS | Flags: END_HEADERS | Stream ID: 1 |
   +-----------------------------------------------+
   | :status = 200                                 |
   | content-type = text/html                      |
   +-----------------------------------------------+
   ```

3. **数据传输**
   - 数据通过独立的流进行传输，避免了队头阻塞问题。
   ```http
   +-----------------------------------------------+
   | Length: ... | Type: DATA | Flags: END_STREAM | Stream ID: 1 |
   +-----------------------------------------------+
   | <html>...                                     |
   +-----------------------------------------------+
   ```

**优势**

1. **减少延迟**
   - **描述：** QUIC协议显著减少了连接建立和数据传输的延迟。
   - **应用场景：** 高延迟网络环境，实时通信应用。

2. **提高传输效率**
   - **描述：** QUIC的多路复用和无队头阻塞特性提高了传输效率。
   - **应用场景：** 大规模数据传输，视频流媒体。

3. **增强安全性**
   - **描述：** 集成TLS加密确保数据传输的安全性。
   - **应用场景：** 任何需要安全传输的应用，如电子商务、在线支付。

4. **提高连接稳定性**
   - **描述：** 支持连接迁移，确保连接在网络条件变化时的稳定性。
   - **应用场景：** 移动设备，动态网络环境。

### HTTPS（超文本传输安全协议）

**HTTPS**（Hypertext Transfer Protocol Secure，超文本传输安全协议）是一种在HTTP协议的基础上增加了SSL/TLS加密层，用于确保数据在客户端和服务器之间传输时的安全性。 HTTPS通过数字证书验证服务器的身份，确保用户访问的是合法的服务器。 HTTPS通过校验机制确保数据在传输过程中没有被篡改。

**HTTPS的工作原理**

- 用户在浏览器中输入URL（例如`https://www.example.com`），发起HTTPS请求。
- 服务器返回SSL/TLS证书，包括服务器的公钥和证书颁发机构（CA）的签名。
- 浏览器验证SSL/TLS证书的合法性，包括检查证书的有效期、颁发机构和证书链。
- 如果证书合法，客户端生成会话密钥，并使用服务器的公钥对会话密钥进行加密，发送给服务器。
- 服务器使用自己的私钥解密会话密钥，双方使用该会话密钥进行加密通信。
- 通过SSL/TLS协议，客户端和服务器建立加密通道，进行安全的数据传输。

## 电子邮件

电子邮件主要由三部分构成：**用户代理（user agent）**、**邮件服务器（mail server）**、**简单邮件传输协议（simple mail transfer protocol，SMTP）**。

## 流媒体

### HTTP流和DASH

**DASH (Dynamic Adaptive Streaming over HTTP,经HTTP的动态适应性流)** 是一种通过HTTP协议实现的实时视频流媒体传输技术。它允许视频流被分割成多个小的片段，视频内容被分割成多个小的片段（通常每个片段几秒钟长），并以不同的质量和比特率进行编码。每个片段都可以根据网络条件动态调整其质量，从而提供更好的观看体验。例如假设你在观看一个高清视频，当网络状况良好时，你会接收到高质量的1080p视频片段；当网络状况变差时，客户端会自动切换到较低质量的480p片段，以保证视频播放的连续性。

**媒体呈现描述文件（MPD）**描述了可用的媒体表示（包括不同的比特率和分辨率），以及各个片段的位置信息(URL地址)。客户端在开始播放视频前，首先下载这个MPD文件。然后通过客户端在 HTTP GET请求报文获取URL。

## 域名系统（DNS）

**域名系统（DNS）** 是因特网的基础服务之一，负责将人类可读的域名（如 www.example.com）转换为计算机可识别的 IP 地址（如 192.0.2.1）。这个过程被称为 DNS 解析（DNS Resolution）。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQQdFOO6wZOFQKK87sLPEErcAdlixwDW7lSIqYcCcLupDpo?width=1024" width="1024" height="auto" />

### 主要组成部分

#### 1.域名空间

DNS 采用分层结构的域名空间，每个层级用点（.）分隔。最高层是根域（.），然后是顶级域（如 .com、.org），接着是二级域（如 example.com）等。 www.example.com 中，根域是 .，顶级域是 .com，二级域是 example，三级域是 www。

#### 2.DNS 服务器

DNS 服务器负责存储和管理域名到 IP 地址的映射关系。主要类型包括根 DNS 服务器、顶级域 DNS 服务器和权威 DNS 服务器。

- **根 DNS 服务器（Root DNS Server）：** 位于 DNS 体系结构的顶端，负责顶级域名服务器的地址信息。
- **顶级域 DNS 服务器（TLD DNS Server）：** 管理特定顶级域（如 .com、.org）的域名信息。
- **权威 DNS 服务器（Authoritative DNS Server）：** 存储特定域的具体 DNS 记录。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQTNdopQY2lmR6_bbCs2BfvfAdXJB8CARJD82tyvtHit30M?width=1024" width="1024" height="auto" />

#### 3.DNS 记录

DNS 记录存储在权威 DNS 服务器上，包含域名和 IP 地址的映射关系，以及其他相关信息。

**类型：**

- **A 记录（Address Record）：** 将域名映射到 IPv4 地址。
- **AAAA 记录：** 将域名映射到 IPv6 地址。
- **CNAME 记录（Canonical Name Record）：** 将一个域名映射到另一个域名。
- **MX 记录（Mail Exchange Record）：** 指定邮件服务器。
- **TXT 记录（Text Record）：** 存储文本信息，用于验证和安全等目的。

### DNS报文 

DNS报文（DNS Message）是用于在DNS客户端和DNS服务器之间传输查询和响应信息的结构化数据。DNS报文可以分为查询报文和响应报文两种类型。无论是查询还是响应，DNS报文的基本结构都是相同的。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQRI6DBLppQVQbYGRFDfgUsBAVbVMEssq5RVGlxTKJrvSU4?width=1024" width="1024" height="auto" />

#### 1. 报文头部（Header）前12个字节

**标识符 (ID)**：

- **作用**：唯一标识每个DNS查询或响应，用于匹配查询和响应。
- **示例**：如ID值为0x1234。

**标志（Flags）**：
- **作用**：包含多种控制和状态标志，如查询/响应标志、操作码、响应代码等。
- **示例**：表示这是一个标准查询或响应，是否权威回答等。

**问题数（QDCOUNT）**：
- **作用**：表示查询部分包含的问题数。
- **示例**：如果有一个查询，这里的值为1。

**回答数（ANCOUNT）**：
- **作用**：表示回答部分包含的资源记录（RRs）数。
- **示例**：如有两个回答记录，这里的值为2。

**授权数（NSCOUNT）**：

- **作用**：表示授权部分包含的资源记录（RRs）数。
- **示例**：如有一个授权记录，这里的值为1。

**附加数（ARCOUNT）**：
- **作用**：表示附加信息部分包含的资源记录（RRs）数。
- **示例**：如有三个附加记录，这里的值为3。

#### 2. 查询问题（Question）

- **作用**：包含查询的具体内容，即域名、查询类型（如A记录）、查询类（如IN，表示Internet）。
- **示例**：查询 `www.example.com` 的 A 记录。

#### 3. 回答（Answer）

- **作用**：包含回答查询的资源记录（RRs），如域名对应的IP地址。
- **示例**：回答 `www.example.com` 的 IP 地址为 `192.0.2.1`。

#### 4. 授权（Authority）

- **作用**：包含权威名称服务器的资源记录（RRs），指示谁是该域名的权威DNS服务器。
- **示例**：指示 `example.com` 的权威名称服务器为 `ns1.example.com`。

#### 5. 附加信息（Additional）

- **作用**：包含额外的资源记录（RRs），提供与查询相关的附加信息。
- **示例**：提供 `ns1.example.com` 的 IP 地址为 `192.0.2.2`。

### DNS查询

在DNS系统中，查询的方式主要有两种：迭代查询（Iterative Query）和递归查询（Recursive Query）。

**迭代查询**是指DNS客户端将查询请求发送给DNS服务器，如果该DNS服务器没有所请求的记录，它会返回一个更接近目标的DNS服务器地址，客户端继续向下一个DNS服务器发送查询请求，直到获取最终结果。**递归查询**是指DNS客户端将查询请求发送给本地DNS解析器（通常由ISP或本地网络提供），由本地DNS解析器全权负责查询的全过程，客户端请求本地DNS解析器，如果没有记录，本地DNS解析器继续查询根DNS服务器，本地DNS解析器查询顶级域DNS服务器，查询权威DNS服务器在这个过程中，直到本地DNS解析器返回结果给客户端。本地DNS解析器可能会与多个其他DNS服务器进行交互，但客户端只等待最终的结果。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQRX7fUEZTWSR5BhWtjQTrhTAS4HREZt1yLAIyuzyYCwEQg?width=1024" width="1024" height="auto" />

### DNS的缓存

**DNS缓存**是一种用于提高DNS查询效率的机制，通过存储以前查询过的域名解析结果，使后续相同的查询可以更快地得到响应。

当DNS客户端（如浏览器或操作系统）向本地DNS解析器发送查询请求时，如果本地DNS解析器之前已经查询过该域名且结果仍在缓存中，则直接从缓存中返回结果，而不需要再次向上级服务器查询。

## 内容分发网络 (CDN)

**内容分发网络（CDN）**是一种分布式的服务器系统，用于高效地传输互联网内容。CDN通过将内容缓存到多个地理位置分布的服务器中，使得用户可以从离自己最近的服务器获取内容，从而提高访问速度，减少延迟。

内容分发网络（CDN）的两种主要服务器安置原则是**深入**和**邀请做客**。**深入**原则是通过在全球范围内的接入ISP（Internet Service Provider）中部署服务器集群，将服务器深入到ISP的接入网络中。这种方法可以显著减少用户感受到的时延和提高吞吐量，但成本较高。**邀请做客**原则是在少数关键位置建造大集群，并邀请ISP在这些位置上做客。这种方法可以大幅降低成本，但可能会导致较高的用户时延和较低的吞吐量。

### CDN通信原理

<img src="https://1drv.ms/i/c/a643854c1477e063/IQTIpqLvSfg0Ta-geY5EAqFYAdnFKMyoqb2IkFWZAyTRcVU?width=710&height=460" width="710" height="460" />

- 用户在浏览器中输入URL，例如`www.example.com`，并发出请求访问网页或资源。
- 用户的请求首先被发送到DNS服务器，DNS服务器将请求解析为CDN边缘服务器的IP地址。
- 浏览器根据解析得到的CDN边缘服务器的IP地址，向最近的边缘服务器发送内容请求。
- CDN边缘服务器收到用户的内容请求后，首先检查缓存中是否有所请求的内容
- 在无缓存内容的情况下，边缘服务器向源服务器请求所需内容
- 边缘服务器将从源服务器获取的内容缓存下来，并将内容返回给用户的浏览器。
- 用户从最近的CDN边缘服务器获取所请求的内容，体验更加快速和流畅的访问。

### CDN集群选择策略

在内容分发网络（CDN）中，选择最合适的服务器集群来处理用户请求是至关重要的。CDN集群选择策略旨在根据多种因素动态选择最佳的边缘服务器，以优化内容传输速度和用户体验。

#### 1.基于地理位置的选择（Geolocation-based Selection）

根据用户的地理位置选择离用户最近的CDN边缘服务器。优点是能够最小化网络延迟，提高内容传输速度。

#### 2.基于负载均衡的选择（Load Balancing-based Selection）

根据CDN边缘服务器的当前负载情况选择最合适的服务器。优点是能够避免服务器过载，提高系统的整体性能和稳定性。

#### 3.基于网络性能的选择（Network Performance-based Selection）

根据网络性能指标（如延迟、带宽、丢包率等）选择最佳的CDN边缘服务器。优点是能够确保选择的服务器具有最佳的网络连接质量，提高传输效率。 

#### 4.基于用户历史记录的选择（User History-based Selection）

根据用户的历史访问记录选择最合适的CDN边缘服务器。优点是能够利用用户的历史行为数据，提高内容传输的个性化和准确性。

#### 5. 多策略综合选择（Multi-strategy Selection）

综合多种选择策略，动态调整选择方案，以达到最佳的效果。

## 套接字编程

---

# 运输层

运输层（Transport Layer）是OSI模型中的第四层，负责在主机之间可靠且高效地传输数据。它是网络通信中非常关键的一部分，因为它提供了端到端的通信服务。

**逻辑通信**指的是在两个计算机系统之间建立虚拟连接，而不依赖于底层的物理网络连接。运输层（Transport Layer）在网络通信中提供了端到端的逻辑通信，确保数据能够可靠、准确地传输到目标主机。

<img src="https://1drv.ms/i/c/a643854c1477e063/IQR25DJIR17aRa4JwHiQneljAYSysBDdsb8Q6G7B3Ih2OYA?width=1040&height=1081" width="1040" height="1081" />

**运输层报文段**（Transport Layer Segment）是运输层协议（如TCP和UDP）在网络上传输的数据单元。报文段是运输层负责处理的数据结构，用于在发送方和接收方之间传递应用层数据。它包括首部（Header）和数据部分（Data），通过封装应用层数据和添加控制信息，实现端到端的可靠数据传输。

## 运输层和网络层的关系

用这个例子解释：考虑有两个家庭，一家位于美国东海岸，另一家位于美国西海岸，每家有12个孩子。东海岸家庭的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每星期都要互相写一封信，每封信都用单独的信封通过传统的邮政服务传送。因此，每个家庭每星期向另一个家庭发送144封信。

每个家庭有个孩子负责收发邮件，西海岸家庭是 Ann 而东海岸家庭是 Bill。每星期 Ann 去她的所有兄弟姐妹那里收集信件，并将这些信件交到每天到家门口来的邮政服务的邮车上。当信件到达西海岸家庭时，Ann 也负责将信件分发到她的兄弟姐妹手上。在东海岸家庭中的 Bill 也负责类似的工作。

在这个例子中，邮政服务为两个家庭间提供逻辑通信，邮政服务将信件从一家送往另一家，而不是从一个人送往另一个人。在另一方面，Ann 和 Bill 为堂兄弟姐妹之间提供了逻辑通信，Ann 和 Bill 从兄弟姐妹那里收取信件或到兄弟姐妹那里交付信件。

注意到从堂兄弟姐妹们的角度来看，Ann 和 Bill 就是邮件服务，尽管他们只是端到端交付过程的一部分（即端点系统部分）。在解释逻辑层和网络层之间的关系时，这个家庭的例子是一个非常好的类比。

| **应用层报文**           | 信封中的信件         |
| ------------------------ | -------------------- |
| **逻辑通信**             | 堂兄弟姐妹           |
| **主机**（又称为端系统） | 家庭                 |
| 运输层协议               | Ann 和 Bill          |
| **网络层协议**           | 邮政服务（包括邮车） |

所以运输层协议都工作在端系统中，在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层）。

## 多路复用与多路分解

### 什么是多路复用？

**多路复用**，简单来说，就是**将多个应用程序的数据流合并到一个传输层数据流中**。当你的电脑运行着多个应用，比如浏览器、音乐播放器、聊天软件等，它们都需要通过网络发送和接收数据。为了有效利用网络资源，运输层会将这些不同来源的数据打包，统一传输。

就像高速公路上的车辆，各自有着不同的目的地，但可以共享同一条道路行驶。这条道路就是网络连接，而车辆则是数据包。

**具体过程：**

1. **应用程序准备数据**：多个应用程序各自生成要发送的数据。
2. **运输层分配源端口号**：运输层为每个应用程序分配一个源端口号。
3. **封装数据段**：运输层将应用程序的数据与源端口号、目的端口号等信息封装成数据段(报文段)。
4. **发送数据段**：运输层将多个数据段发送给网络层，实现多个应用程序数据的聚合传输。

### 什么是多路分解？

**多路分解**是多路复用的逆过程。当数据到达目的地后，运输层需要**根据数据包中的信息，将其正确地分发给对应的应用程序**。这就好比在快递中心，工作人员根据包裹上的地址，将包裹分别投递到不同的收件人手中。

**具体过程：**

**接收数据段**：运输层接收到来自网络层的数据段。

**提取目的端口号**：运输层从数据段头部提取目的端口号。

**查找匹配的套接字**：运输层在套接字列表中查找与目的 IP 地址和目的端口号匹配的套接字。

**将数据传递给应用程序**：找到匹配的套接字后，运输层将数据段中的数据传递给对应的应用程序。

### 端口号的作用

多路复用和多路分解的关键在于**端口号**。每个应用程序在运输层都有一个唯一的端口号，当数据被发送或接收时，都会附带相应的端口号。

- **源端口号**：标识发送数据的应用程序。
- **目的端口号**：标识接收数据的应用程序。

通过端口号，运输层能够准确地知道数据来自哪里，应该发往何处。

### 无连接的多路复用与多路分解

## 无连接运输UDP

**UDP**（用户数据报协议）是OSI模型中传输层的一个重要协议，它提供了一种无需建立连接的简单通信方式，因此被称为**无连接传输协议**。UDP 为应用程序提供了高效的、低延迟的数据传输方式，适用于对实时性要求高但对可靠性要求不高的场景。

### UDP 的主要特点

**无连接**：UDP 在传输数据前**不需要建立连接**，通信双方可以直接发送数据报文（Datagram）。

**不可靠传输**：UDP 不保证数据的可靠性，不提供重传机制，数据可能会丢失、重复或乱序到达。

**报文导向**：UDP 面向报文传输，发送方的应用程序需要将数据划分为合适的大小，接收方按报文边界读取数据。

**速度快、开销小**：由于无需建立连接、无需维护连接状态，UDP 的头部开销较小（仅8字节），传输效率高。

**支持一对一、一对多、多对一和多对多的交互通信**：这使得 UDP 适用于广播和多播应用。

### UDP 数据报格式

UDP 数据报的头部非常简洁，仅包含四个字段，每个字段占用 2 个字节（16 位）：

1. **源端口号（Source Port）**：可选字段，指示发送数据报的应用程序的端口号。
2. **目的端口号（Destination Port）**：指示接收数据报的应用程序的端口号。
3. **长度（Length）**：UDP 数据报的总长度，包括头部和数据部分的长度，最小值为 8 字节。
4. **校验和（Checksum）**：用于检测数据在传输过程中是否发生错误。

### UDP 的优缺点

**优点：**

- **低延迟、高效率**：由于无需建立连接，头部开销小，适合实时性要求高的应用。
- **简单易用**：协议简单，实现容易，资源占用少。
- **支持广播和多播**：适合需要同时向多个目标发送数据的场景。

**缺点：**

- **不可靠传输**：不保证数据的可靠性，数据可能丢失、重复或乱序，应用程序需要自行处理。
- **无拥塞控制**：可能导致网络拥塞，影响网络稳定性。
- **无流量控制和拥塞避免机制**：不适合需要可靠传输的应用。

### UDP 的常见应用场景

1. **视频直播和语音通信**：如 IPTV、VoIP、实时视频会议等，对实时性要求高，能容忍部分数据丢失。
2. **在线游戏**：需要快速响应，使用 UDP 可以减少延迟，提高游戏体验。
3. **DNS 查询**：DNS 使用 UDP 进行域名解析请求，速度快，开销小。
4. **DHCP（动态主机配置协议）**：用于分配 IP 地址，基于 UDP 运行。
5. **广播和多播应用**：如 IPTV 广播、实时股票行情分发等。

## 面向连接的运输TCP

**TCP**（传输控制协议）是互联网中至关重要的传输层协议，被广泛应用于需要可靠数据传输的场景。作为一种**面向连接**的协议，TCP 在数据传输前需要建立连接，确保数据的可靠性、有序性和完整性。让我们深入了解 TCP 的工作原理、特点和应用。

### TCP 的主要特点

1. **面向连接**：在传输数据之前，TCP 要求通信双方建立一个虚拟的连接，称为 **TCP 连接**，通过 **三次握手** 建立，保证双方的通信能力。
2. **可靠传输**：TCP 提供可靠的数据传输服务，确保数据包不会丢失、重复或乱序到达。如果发生数据丢失，TCP 将自动进行重传。
3. **流量控制**：通过滑动窗口机制，TCP 能够根据接收方的处理能力，调节发送方的数据发送速率，防止网络拥塞和接收方溢出。
4. **拥塞控制**：TCP 实施了拥塞避免和控制算法，如 **慢启动**、**拥塞避免**、**快速重传** 和 **快速恢复**，以防止网络过载。
5. **全双工通信**：通信双方可以同时发送和接收数据。
6. **面向字节流**：TCP 将应用程序的数据视为连续的字节流，而不是离散的报文。

### TCP 的工作原理

#### **三次握手（建立连接）**

在数据传输之前，TCP 通过三次握手建立连接：

1. **第一次握手**：客户端发送一个带有 **SYN（同步序列号）** 标志的数据包，表明希望建立连接，并发送初始序列号 **Seq=x**。
2. **第二次握手**：服务器收到后，回复一个带有 **SYN** 和 **ACK（确认序列号）** 标志的数据包，确认收到客户端的请求，发送自己的初始序列号 **Seq=y**，并对客户端的序列号 **Ack=x+1**。
3. **第三次握手**：客户端收到后，发送一个带有 **ACK** 标志的数据包，确认收到服务器的序列号 **Ack=y+1**。

完成三次握手后，连接建立，双方可以开始传输数据。

<iframe src="https://1drv.ms/p/c/a643854c1477e063/IQR9dwEUpf-9Qaj8r2O0Vn4nARvMOkY9KkAIihPTCy1LpkU" width="500" height="500" frameborder="0" scrolling="no"></iframe>

####  **数据传输**

- **序列号和确认号**：每个数据包都有序列号和确认号，确保数据的有序性和完整性。
- **滑动窗口**：控制数据流的机制，调整发送方的发送速率，根据接收方的缓冲区大小和网络状况动态变化。
- **超时重传**：如果发送方在一定时间内未收到确认，认为数据丢失，自动重传。

#### **四次挥手（连接释放）**

在数据传输完成后，TCP 通过四次挥手释放连接：

1. **第一次挥手**：客户端发送一个带有 **FIN（终止）** 标志的数据包，表示要关闭连接。
2. **第二次挥手**：服务器收到后，发送一个带有 **ACK** 标志的数据包，确认收到关闭请求。
3. **第三次挥手**：服务器发送一个带有 **FIN** 标志的数据包，表示同意关闭连接。
4. **第四次挥手**：客户端收到后，发送一个带有 **ACK** 标志的数据包，确认关闭。

连接释放完成，双方断开通信。

<iframe src="https://1drv.ms/p/c/a643854c1477e063/IQQebMsU2YR3R6-EUVekYNsoAZtkzBNGHAX1S7BhHR4St34" width="500" height="500" frameborder="0" scrolling="no"></iframe>

## SSL/TLS协议

SSL（Secure Socket Layer，安全套接层）和TLS（Transport Layer Security，传输层安全协议）是用于在网络通信中提供数据加密和身份验证的协议。

### **SSL/TLS协议的组成**：

- **SSL记录协议**：负责封装、压缩、加密和传输数据。
- **SSL握手协议**：在实际数据传输开始前，用于身份认证、协商加密算法和交换加密密钥。

# 网络层

网络层的数据平面（Data Plane），也称转发平面（Forwarding Plane），是网络设备（如路由器和交换机）中负责处理和转发数据包的部分。它的主要职责是根据已经建立的路由表和转发表，将接收到的数据包快速且高效地转发到目的地。

## 转发和路由选择

### 路由选择（Routing）

**路由选择**是指确定数据包传输路径的过程。路由选择在网络层执行，主要涉及以下几个方面：

1. **路由表维护**：路由器通过运行路由协议（如OSPF、BGP）来学习和维护网络拓扑信息，并根据这些信息生成路由表。
2. **路径计算**：路由选择算法（如Dijkstra算法、Bellman-Ford算法）用于计算最佳路径。这些算法基于各种度量标准，如跳数、带宽、延迟等。
3. **更新和传播**：路由器之间会定期交换路由信息，以确保路由表的更新和一致性。

### 转发（Forwarding）

**转发**是指根据路由表，将接收到的数据包转发到下一跳（下一个路由器或最终目的地）的过程。转发过程在数据平面执行，主要包括以下几个步骤：

1. **查找路由表**：路由器接收到数据包后，会查找路由表，确定数据包的转发路径。
2. **修改数据包头信息**：根据需要，路由器会修改数据包的头信息，如TTL（生存时间）字段，以反映数据包经过的跳数。
3. **转发数据包**：根据查找到的转发路径，将数据包从输入端口转发到输出端口。

假设我们有三个路由器A、B和C，构成了一个简单的网络。A和B之间有一条链路，B和C之间有一条链路。

1. **路由选择**：A和C之间的路径可以通过B到达，路由表会记录这个路径。
2. **转发**：当A接收到一个发往C的数据包时，A会查找路由表，发现需要通过B转发数据包。然后A将数据包发送给B，B再将数据包转发给C。

## 控制平面

在网络中，控制平面是负责制定路由选择策略和维护路由表的部分。它通过不同的机制和协议来管理数据的传输路径。以下是控制平面的两种主要方法：

### 分布式控制平面
在传统网络架构中，控制平面是分布式的，每个网络设备（如路由器和交换机）都独立运行控制平面的功能。主要特点和优势包括：

- **自主决策**：每个设备根据自身的路由协议（如OSPF、BGP）和算法，独立计算最佳路径，并维护自己的路由表。
- **高可靠性**：由于控制平面是分布式的，即使某个设备故障，网络仍能继续运行。
- **弹性和扩展性**：适用于大规模网络，设备之间通过动态路由协议共享信息，自动适应网络拓扑变化。

举个例子，在OSPF（开放最短路径优先）协议中，每个路由器都会计算到达每个目的地的最短路径，并将其存储在路由表中。路由器之间通过链路状态通告（LSA）交换信息，以确保路由表的更新和一致性。

### 集中式控制平面
随着软件定义网络（SDN）的兴起，集中式控制平面成为一种新的网络架构。主要特点和优势包括：

- **集中管理**：控制平面由一个或多个集中控制器管理，负责全局的路由选择和策略制定。
- **简化配置**：网络设备仅负责数据平面的转发功能，减少了配置复杂度。
- **灵活性和可编程性**：通过开放接口（如OpenFlow），网络管理员可以动态调整路由策略和流量管理，更灵活地应对业务需求。

举个例子，在SDN架构中，OpenFlow协议允许集中控制器与网络设备通信，控制器根据全局视图计算最佳路径，并将转发规则下发到设备。设备根据这些规则转发数据包，实现控制与转发的分离。

## IP服务模型

IP服务模型是互联网协议（IP）用于传输数据的基础。以下是IP服务模型的一些关键点：

1. **IP数据报**：IP数据报包含需要传输的数据以及目标终端和发送终端的IP地址。数据报通过网络从一个路由器传递到另一个路由器，直到到达目标地址。
2. **不可靠传输**：IP不保证数据报一定会送达目的地，可能会延迟、顺序错乱，甚至无法送达。
3. **尽最大可能传输**：IP只在必要时丢弃数据报，路由器中的数据报队列可能因拥塞而满载，迫使路由器丢弃下一个到达的数据报。
4. **无连接**：IP不维护与通信相关的任何状态，不建立端到端的状态。
5. **生存时间（TTL）**：IP在每个数据报的头部添加一个跳数字段（TTL），每经过一个路由器就减1，如果减到0，数据报会被丢弃。
6. **数据报分片**：如果数据报太长，IP会对其进行分片，以便在不同类型的链路上传输。
7. **头部校验和**：IP在数据报头部包含一个校验和字段，以确保数据报被传送到正确的位置。
8. **IP版本**：目前使用的IP有两个版本，IPv4拥有32位地址，IPv6拥有128位地址。
9. **头部字段**：IP数据报头部包含源端IP地址、目标端IP地址、协议ID、版本、总长度、TTL、分片信息、服务类型、头部长度、可选字段和校验和。

### IPv4地址

**网际协议版本4**（Internet Protocol version 4，IPv4），又称互联网[通信协议](https://baike.baidu.com/item/通信协议/3351624?fromModule=lemma_inlink)第四版，是[网际协议](https://baike.baidu.com/item/网际协议/4148798?fromModule=lemma_inlink)开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。此协议会尽最大努力交付[数据包](https://baike.baidu.com/item/数据包/489739?fromModule=lemma_inlink)，意思是它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。

[IPv4地址](https://baike.baidu.com/item/IPv4地址/16742558?fromModule=lemma_inlink)可被写作任何表示一个32位整数值的形式，但为了方便人类阅读和分析，它通常被写作点分十进制的形式，即四个字节被分开用[十进制](https://baike.baidu.com/item/十进制/6521392?fromModule=lemma_inlink)写出，中间用点分隔。

![IPv4](https://1drv.ms/i/c/a643854c1477e063/IQR9pGq3i0iTQanRhjhdCSVpAR_OpMr1PRG1Sz9Tlnho1Ks?width=1198&height=1745)

#### 1.子网掩码

子网掩码（Subnet Mask）是一种用于划分IP地址网络部分和主机部分的32位二进制数。它用于确定一个IP地址所属的子网范围。**子网掩码的表示方式**： 子网掩码通常用点分十进制表示，例如：

- 255.255.255.0~24
- 255.255.0.0~16
- 255.0.0.0~8

IP地址 **192.168.1.1/24** 使用的是CIDR表示法（无类别域间路由，Classless Inter-Domain Routing）。这种表示法结合了IP地址和子网掩码的信息。

- **192.168.1.1** 是IP地址。
- **/24** 表示子网掩码的前24位是1，其余位是0。

我们可以将/24转换成传统的点分十进制表示的子网掩码：

二进制形式的子网掩码是 11111111.11111111.11111111.00000000，对应的点分十进制形式是 **255.255.255.0**。

![子网掩码](https://1drv.ms/i/c/a643854c1477e063/IQQIeiCWdZTMToPBgqRhm_t3AerL00CU-1h-GdNtkTBo-8w?width=1146&height=442)

#### 2.IPv4的分类

**A类地址**:

- 范围：0.0.0.0 到 127.255.255.255
- 0NNNNNNN.NNNNNNN.NNNNNNN.NNNNNNN(第一位固定为0)
- 默认子网掩码：255.0.0.0
- 网络位：1.0.0.0~126.0.0.0
- 特点：用于大型网络，可以容纳大量的主机。A类地址的网络部分用第一个八位字节（即第一个点前面的数字）表示。

**B类地址**:

- 范围：128.0.0.0 到 191.255.255.255
- 10NNNNNN.NNNNNNNN.NNNNNNNN.NNNNNNNN(前两位固定为10)
- 默认子网掩码：255.255.0.0
- 网络位：128.0.0.0~191.255.0.0
- 特点：用于中型网络，网络部分使用前两个八位字节（即前两个点前面的数字）表示。

**C类地址**:

- 范围：192.0.0.0 到 223.255.255.255
- 110NNNNN.NNNNNNNN.NNNNNNNN.NNNNNNNN(前三位固定位110)
- 默认子网掩码：255.255.255.0
- 网络位：192.0.0.0~223.255.255.0
- 特点：用于小型网络，网络部分使用前三个八位字节表示。

**D类地址**:

- 范围：224.0.0.0 到 239.255.255.255
- 1110NNNN.NNNNNNNN.NNNNNNNN.NNNNNNNN
- 特点：用于多播（Multicast），即将数据包发送到一组特定的主机。

**E类地址**:

- 范围：240.0.0.0 到 255.255.255.255
- 1111NNNN.NNNNNNNN.NNNNNNN.NNNNNNNN
- 特点：保留用于未来和实验用途，不用于常规的IP地址分配。

#### 3..IP地址类型

**网段：**我们通常把一个网络号所定义的网络范围称为一个网段。

**网络地址（Network Address）**是用来标识一个网络的唯一地址。它通常是通过将某个IP地址与子网掩码进行按位与（AND）操作后得到的结果（主机位全部为0）。网络地址用于确定一个网络的范围，它不分配给具体的设备，而是代表整个网络。

![网络地址](https://1drv.ms/i/c/a643854c1477e063/IQT4cDdeJ-eRSJVoQL2LZ5XGAYLmvn7qtkUk3tedNnWjZdk?width=1024)

**192.168.1.0/24** 这个网络的IP地址范围如下：

- **网络地址**：192.168.1.0
- **可用主机地址范围**：192.168.1.1 到 192.168.1.254
- **广播地址**：192.168.1.255

**广播地址：**广播地址是网络通信中用于向同一网络内所有设备发送数据包的特殊地址。它的主要功能是确保消息可以同时传递给网络中的所有设备，而无需单独指定每个目标。（主机位全部位1）

```bash
11000000.10100010.00000001.00000000 #主机地址192.168.1.1
11111111.11111111.11111111.00000000 #子网掩码255.255.255.0
11000000.10100000.00000001.11111111 #广播地址192.168.1.255
```

**可用地址：**除去广播地址和网络地址外的所有地址。

#### 4.可用主机范围

**确定子网掩码的主机位数：**

子网掩码 **255.255.255.0** 的前24位是1，其余8位是0，这里有 **8位** 是主机位。

计算公式：
$$
2^{主机位数}-2=可用主机
$$

#### 5.私网与公网IP地址

**公网IP地址：**公网IP是由IANA机构统一分配的，以保证任何一个IP地址在Internet上的唯一性。

**私网IP地址：**私网IP地址（Private IP Address）是专门为局域网（LAN）中的设备分配的IP地址，不直接用于互联网通信。它们在不同的局域网中可以重复使用，但在互联网中不可路由。

| IP地址范围     | 类别        | 子网掩码    | 可用主机数 | 主要用途              |
| -------------- | ----------- | ----------- | ---------- | --------------------- |
| 10.0.0.0/8     | A类私网地址 | 255.0.0.0   | 16,777,214 | 大型网络（企业内部）  |
| 172.16.0.0/12  | B类私网地址 | 255.240.0.0 | 1,048,574  | 中型网络              |
| 192.168.0.0/16 | C类私网地址 | 255.255.0.0 | 65,534     | 小型网络（家庭/办公） |

#### 6.特殊IP地址

| 特殊IP地址   | 地址范围        | 作用                                                         |
| ------------ | --------------- | ------------------------------------------------------------ |
| 有限广播地址 | 255.255.255.255 | 可作为目的地址，发往该网段所有主机（受限于网关）             |
| 任意地址     | 0.0.0.0         | “任何网络”的网络地址；“这个网络上这个主机接口”的IP地址       |
| 环回地址     | 127.0.0.0/8     | 测试设备自身的软件系统                                       |
| 本地链路地址 | 169.254.0.0/24  | 当主机自动获取地址失败后，可使用该网段中的某个地址进行临时通信 |

### IPv6

IPv6（Internet Protocol version 6）是为了解决IPv4地址不足问题而设计的，提供了更大的地址空间和一些增强的功能。IPv6地址由128位（16字节）组成，通常使用十六进制表示。`2001:0db8:85a3:0000:0000:8a2e:0370:7334`

#### 全局单播地址（GlobalunicastAddress）

- 定义：全局单播地址是IPv6地址中的一种类型，用于全球唯一的标识符。这些地址类似于IPv4中的公
  有地址，可以在互联网上被路由，并用于唯一标识一台设备。
- 格式：全局单播地址通常以2000:：/3开头。
- 用途：用于互联网上的端到端通信。
- 例子:2001:0db8:85a3:0000:0000:8a2e:0370:7334

#### 链路本地地址（Link-LocalAddress）
- 定义：链路本地地址用于同一链路（例如一个物理网络）上的
  节点之间的通信。
- 格式：链路本地地址以FE80：：/10开头。
- 用途：自动配置（Autoconfiguration）、邻居发现（Neighbor
  Discovery）、无状态地址自动配置（Stateless Address
  Autoconfiguration) 等。
- 例子:FE80:：1234:56FF:FE78:9ABC

#### 站点本地地址 (Site-Local Address)
- 定义：站点本地地址用于同一站点内（比如校园网）的节点间的通信。在IPV6中，站点本地地址的概
  念已经被弃用，取而代之的是独特的本地地址（Unique Local Address）。
- 格式：独特的本地地址以FD00：：/8开头。
- 用途：用于没有互联网连接的私有网络。
- 例子：FD00:：1234:5678::1

#### 多播地址(MulticastAddress)
- 定义：多播地址用于一对多的通信。数据包发送到一个多播
  地址，该地址被一组接口监听，所有这些接口都会接收到数
  据包。
- 格式：IPv6多播地址以FF00：：/8开头。
- 用途：视频流、实时音频、在线游戏、实时数据分发等。
- 例子：FF02::1(所有节点)
- 例子：FF02::2(所有路由器)

#### 任播地址(Anycast Address)
- 定义：任播地址用于指定一组接口中的任意一个接收数据。数据包会被路由到最近的接口。
- 格式：任播地址在IPV6中没有特定的格式，它实际上是全局单播地址的一个特殊用途。
- 用途：服务器集群、负载均衡、内容分发网络（CDN）等。
- 例子：假设有一组服务器使用相同的全局单播地址作为任播地址：2001:db8:1234：:1。当数据包被
  发送到这个地址时，它会被路由到最近的服务器接口。

### 数据报格式

一个IP数据报由**首部**和**数据**两部分组成。首部的前一部分长度是固定的，共20字节，是所有IP数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。

#### IP数据报首部的固定部分中的各字段

**版本**：占4位，指协议IP的版本。

- 通信双方使用的协议IP的版本必须一致。
- 两种版本：IPv4和IPv6。

**首部长度**：占4位，可表示的最大十进制数值是15。（请注意，首部长度字段所表示数的单位是32位字长（1个32位字长是4字节。）

- IP首部的固定部分是20字节，

  - 因此首部长度字段的最小值是5（即二进制表示的首部长度是`0101`）。

  - 而当首部长度字段为最大值`1111`时（即十进制的15)，就表明首部长度达到最大值：15个32位字长，即60字节。
- 当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现协议IP时较为方便。
- 首部长度限制为60字节的缺点是有时可能不够用，但这样做是希望用户尽量**减少开销**。

- 最常用的首部长度是20字节，不使用任何可选字段。


**区分服务**：占8位，用来获得更好的服务。

- 这个字段在旧标准中叫作服务类型，但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务DS(DifferentiatedServices)。
- 只有在使用区分服务时，这个字段才起作用。
- 在一般的情况下都不使用这个字段。

**总长度**：总长度指**首部和数据之和**的长度，单位为**字节**。

- 总长度字段为16位，因此数据报的最大长度为2¹⁶-1=65535字节。然而实际上传送这样长的数据报在现实中是极少遇到的。（在IP层下面的每一种**数据链路层协议**都规定了一个数据帧中的数据字段的最大长度，这称为**最大传送单元MTU**(Maximum Transfer Unit)。）
- 当一个IP数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的MTU值。（例如，最常用的[以太网](https://so.csdn.net/so/search?q=以太网&spm=1001.2101.3001.7020)就规定其MTU值是1500字节。）
- 若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行**分片处理**。

虽然使用尽可能长的IP数据报会使传输效率得到提高，但数据报短些也有好处。IP数据报越短，路由器转发的速度就越快。为此，协议IP规定，在互联网中所有的主机和路由器必须能够接受长度不超过576字节的数据报。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。在进行分片时，数据报首部中的“总长度”字段是指分片后的每一个分片的首部长度与该分片的数据长度的总和。

**标识**(identification)：占16位。

- IP软件在存储器中维持一个**计数器**，每产生一个数据报，计数器就加1，并将此值赋给**标识字段**。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。
- 当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。（相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。）

**标志**(flag)：占3位，但目前只有两位有意义。

- 标志字段中的最低位记为MF(More Fragment)。
  - `MF=1`即表示后面“还有分片”的数据报。
  - `MF=0`表示这已是若干数据报片中的最后一个。

- 标志字段中间的一位记为DF(Don’t Fragment)，意思是“不能分片”。
  - 只有当`DF=0`时才允许分片。

**片偏移**：占13位。

- 片偏移指出：较长的分组在分片后，**某片在原分组中的相对位置**。也就是说，相对于用户数据字段的起点，该片从何处开始。
- 片偏移以8个字节为偏移单位。这就是说，除最后一个数据报片外，其他每个分片的长度一定是8字节（64位）的整数倍。

```
一个数据报的总长度为3820字节，其数据部分为3800字节长（使用固定首部），需要分片为长度不超过1420字节的数据报片。因固定首部长度为20字节，因此每个数据报片的数据部分长度不能超过1400字节。于是分为3个数据报片，其数据部分的长度分别为1400，1400和1000字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。下图给出分片后得出的结果。
```

![片偏移](../../../%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/21fe5a5020a03fe6ae3ccbabe669d067.png)

**生存时间**：占8位，生存时间字段常用的英文缩写是TTL(Time To Live)

- 表明这是数据报在网络中的寿命。
- 由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子，因而白白消耗网络资源。
- TTL的意义是指明数据报在互联网中至多可经过多少个路由器。
- 路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃这个数据报，不再转发。因此，TTL的单位是跳数。
- 数据报能在互联网中经过的路由器的最大数值是255。
- 若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。

**协议**：占8位

- 协议字段指出此数据报携带的数据**使用何种协议**，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理。

- 常用的一些协议和相应的协议字段值如下：

  ![协议](../../../%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/4f9e4e3dd27caf1b2b6b9ec3a647aa99.png)

**首部检验和**：占16 位。

- 这个字段**只检验数据报的首部**，**不包括数据部分**。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和，所以首部需要检验。（不检验数据部分可减少计算的工作量。）
- IP首部的检验和不采用复杂的CRC检验码，而采用下面的简单计算方法：
  - 在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。
  - 若首部未发生任何变化，则此结果必为0，于是就保留这个数据报；否则即认为出差错，并将此数据报丢弃。

![检验和](../../../%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/e61a3461e358b73761b6a368b1b07176.png)

**源地址**：占32位。

- 发送IP数据报的主机的IP地址。

**目的地址**：占32位。

- 接收IP数据报的主机的P地址

#### IP数据报首部的可变部分

IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从1字节到40字节不等，取决于所选择的项目。

- 某些选项项目只需要1字节，它只包括1字节的选项代码。

- 而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全0的填充字段补齐为4字节的整数倍。

增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。

实际上这些选项很少被使用。很多路由器都不考虑IP首部的选项字段，因此新的IP版本IPv6就把IP数据报的首部长度做成固定的了。

#### 数据报分片

如果报文长度超过了数据链路所支持的最大长度，则报文就需要分割成若干个较小的片段才能够在链路上传输。主要用到`identification、flags、fragment offset`字段。

![数据包分片](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87.jpg?sign=eQmwXwirBX74u6G3F6yeL7gehyeJvwuJKp6htfuunTA=:0)

#### 生存时间TTL

TTL字段设置了数据包可以经过的路由器数目。一旦经过一个路由器，TTL值就会减1，当该字段值为0时，数据包将被丢弃。

![TTL](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/TTL.jpg?sign=N7BDIsJx-VJPnpeMLpQ6FO_ke1VqifR3lekvgy6qSlc=:0)

**环路**是指信号、数据或路径在网络中循环往复的现象。当发生环路时，数据会在网络中不断循环，无法正常传递到目标节点。会导致网络性能下降、广播风暴、设备过载。

![环路](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E7%8E%AF%E8%B7%AF%2000_00_00-00_00_30.gif?sign=2LEe-yjjIs_9CO2PaNMZOtns0wcrPDh7MV4JOB-7nQ8=:0)

- **长度**：8bit
- **范围：**0~255
- TTL可以防止环路
- TTL帮助限制数据包在网络中的生命周期，防止过时或丢失的包无限传播，保证网络资源高效使用。
- TTL是网络诊断工具（如`traceroute`）的重要组成部分。通过逐步减少TTL值，可以跟踪数据包经过的每一跳设备，定位问题所在。
- TTL可以间接反映数据包经过的跳数，从而帮助管理员分析路径的质量，识别潜在的瓶颈或冗长路由。
- 限制数据包生命周期可以减少路由器和网络资源的无效消耗，尤其是在网络出现故障或攻击（如拒绝服务攻击）时。

#### 协议号（Protocol）

协议号指出数据包携带的数据使用何种协议，以便目的主机的IP层将数据部分上报给哪个进程处理。

![协议号](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E5%8D%8F%E8%AE%AE%E5%8F%B7.jpg?sign=udUEaZFazUfXUXwR06M7Get1zlEWAEVSxwlUN80YPs8=:0)

### IP寻址

**网络部分：**用来标识一个网络，代表IP地址所属网络。

**主机部分：**用来区分一个网络内的不同主机，能唯一标识网段上的某台设备。

#### 二层网络寻址

	二层网络寻址通常指的是基于数据链路层（OSI模型的第二层）的通信地址机制，其核心是使用MAC地址（Media Access Control Address）进行设备标识和数据传输。
	
	例如一个小区内，小区就是网络部分，某人某户就是主机部分，门牌号就是MAC地址，你可以直接通过门牌号访问住户。所以一个小区内只需要使用交换机通过MAC地址就能通信。

![二层寻址](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E4%BA%8C%E5%B1%82%E5%AF%BB%E5%9D%80.jpg?sign=utl-zbXOHjdAc54hXgkOHsRN_Kzhax8G9n8WQdckmP4=:0)

#### 三层网络寻址

三层寻址主要指的是网络层（OSI模型第三层）的地址机制，用于在不同网络之间进行通信。三层寻址的核心是IP地址（Internet Protocol Address），它是网络层通信的关键。

就比如送快递，在同城内你可以找到某个街道某户。但在其他城市你肯定不熟悉，找不到地址，所以需要快递站来查询分配地址。快递站就相当于路由器，可以进行三层网络寻址。

![三层寻址](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E4%B8%89%E5%B1%82%E5%AF%BB%E5%9D%80.jpg?sign=WZhRnoeDcGwv3LU__E_TBPLyuj1bJuuOMo6F2UitFoA=:0)

### 子网划分

1. 原网段分析

   例如：192.168.10.0/24网段

   	网络地址：192.168.10.0
			
   	子网掩码：255.255.255.0
			
   	广播地址：192.168.10.255
			
   	可用地址范围：2⁸-2=254

2. 向主机借位，形成子网

   ![子网划分](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.jpg?sign=cWeHgmpjx-uGLJ-o048B41wKiJSSajuGqVdt6JSXeGQ=:0)

3.多子网划分

- 先将拥有最多客户端的子网所需最少IP数算出
- 在算出所需的主机位
- 通过子网掩码划分子网

### IP地址规划

![ip地址规划](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/IP%E5%9C%B0%E5%9D%80%E8%A7%84%E5%88%92.jpg?sign=WoFCiBSsdIhnUVIWj2TVTtUOsBqSQYd8uw3hbkIa2tk=:0)

#### 规划原则

- 唯一性：一个IP网络中不能有两个主机采用相同的IP地址。
- 连续性：连续地址在层次结构网络中易于进行路由汇总，大大缩减路由表，提高路由计算的效率，加速路由收敛。
- 扩展性：地址分配在每一层次上都要有合理的预留，在网络规模扩展时能保证路由汇总所需的连续性。避免网络扩展造成的地址、路由重新规划。
- 结构化、业务相关性：地址规划与网络拓扑结构和网络承载业务结合起来，便于路由规划和QoS部署。好的IP地址规划使得每个地址都是有实际含义，看到一个地址就可以大致判断出该地址所属的设备和对应的业务。

## 路由器工作原理

		路由器是一种在计算机网络中起到关键作用的设备，它通过管理数据包的转发来确保信息能够从一个网络到达另一个网络（将不同局域网打通）。以下是路由器的工作原理的简要说明：

1. **数据包的接收**：路由器从一个网络接口接收数据包。每个数据包都包含源IP地址、目标IP地址以及其他相关信息。
2. **数据包解析**：路由器检查数据包的目标IP地址，并查找其内部路由表，以确定该数据包的下一个跳点（下一步要发送到的地方）。
3. **路由选择**：基于路由表中的信息，路由器决定数据包的最佳传输路径。这可能涉及多个中间路由器，最终将数据包传送到其目标地址。
4. **数据包转发**：路由器通过适当的网络接口将数据包转发到下一跳点。这一过程不断重复，直到数据包到达其最终目的地。
5. **网络地址转换（NAT）**：在需要时，路由器还可以执行NAT，将私有IP地址转换为公共IP地址，以便在互联网上传输数据。
6. **防火墙功能**：许多路由器还具有防火墙功能，可以过滤和监控进出网络的数据包，以提高网络安全性。
7. **质量服务（QoS）管理**：一些高级路由器能够根据特定的流量类型（如视频、语音等）来优先处理数据包，从而确保关键应用的性能。
8. **冗余和故障转移**：为了提高可靠性，路由器可以配置冗余路径，当主要路径出现故障时，能够自动切换到备用路径。

### 工作流程

接收数据包 → 检查目标IP → 查找路由表 → 选择出口接口 → 封装新帧头 → 转发数据包

### 路由表



## ICMP协议

ICMP（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/报文/3164352?fromModule=lemma_inlink)协议。它是[TCP/IP](https://baike.baidu.com/item/TCP%2FIP/214077?fromModule=lemma_inlink)协议簇的一个子协议，用于在IP[主机](https://baike.baidu.com/item/主机/455151?fromModule=lemma_inlink)、[路由器](https://baike.baidu.com/item/路由器/108294?fromModule=lemma_inlink)之间传递控制消息。控制消息是指网络通不通、[主机](https://baike.baidu.com/item/主机/455151?fromModule=lemma_inlink)是否可达、[路由](https://baike.baidu.com/item/路由/363497?fromModule=lemma_inlink)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

### ICMP协议报文

	ICMP协议报文有多种类型，不同类型又有不同的代码。检验和字段用于检查消息是否完整。

![ICMP报文](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/icmp%E5%8D%8F%E8%AE%AE.jpg?sign=b6nzHt9C2oenrXPBkBoXXBHWh1j7R6FPSef01vh1ksU=:0)

### ICMP重定向

	在特定情况下，当路由器检测到一台机器使用非最优路由的时候，他会向该主机发送一个ICMP重定向报文，请求主机改变路由。

![icmp重定向](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/ICMP%E9%87%8D%E5%AE%9A%E5%90%91.jpg?sign=GkYSqubM0m-gM1ll72K4-8w183UZSaDBtLkmqC6KKAs=:0)

- ICMP重定向过程：
  1. 主机A希望发送报文到服务器A，于是根据配置的默认网关地址向网关RTB发送报文。
  2. 网关RTB收到报文后，检查报文信息，发现报文应该转发到与源主机在同一网段的另一个网关设备RTA，此转发路径是更优的路径，所以RTB会向主机发送一个Redirect消息，通知主机直接向另一个网关RTA发送该报文。
  3. 主机收到Redirect消息后，会向RTA发送报文，然后RTA会将该报文再转发给服务器A。

### ICMP差错检测

	ICMP Echo消息常用于诊断和目的之间的网络连通性，同时还可以提供其他信息，如报文往返时间等。
	
	`ping`命令是一个网络实用程序，用于测试主机之间的网络连接和响应时间。它发送ICMP回显请求（也称为“ping”）到目标主机，并等待回应。

```bash
# 基本使用
ping 192.168.1.1

# 指定发送数据包的数量
ping -n 5 google.com

# 指定数据包大小
ping -l 128 google.com

# 禁止数据包分片（IPv4）
ping -f google.com

# 设置每个回复的超时时间（毫秒）
ping -w 1000 google.com

# 使用 IPv6 测试连接
ping -6 ipv6.google.com
```

### ICMP错误报告 	

	ICMP定义了各种错误报告，用于诊断网络连接性问题；根据这些错误信息，源设备可以判断出数据传输失败的原因。
	
	`tracert`（在Linux系统中对应命令是`traceroute`）是一种网络诊断工具，用于显示数据包从源主机到目标主机所经过的路由路径。它通过逐步增加数据包的TTL（生存时间）值来测试路径上的每一跳，同时收集每一跳的响应时间。

```bash
# 基本使用：显示到目标主机的路由路径
tracert www.google.com

# 参数：
# -d  不解析IP地址为主机名，加快速度
tracert -d www.google.com

# -h <最大跳数> 指定搜索路径的最大跳数
tracert -h 20 www.google.com

# -w <超时时间> 指定每跳的响应时间（单位：毫秒）
tracert -w 100 www.google.com

# -4 强制使用IPv4
tracert -4 www.google.com

# -6 强制使用IPv6
tracert -6 ipv6.google.com
```

![tracert命令](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/tracert%E5%91%BD%E4%BB%A4.png?sign=VzKIHlYJqZ46nf0QVY1JiYhFMJ8_w32J0oHJsEpF0hM=:0)

从上图可以知道从本机到www.baidu.com服务器经过了14个节点和到达该点的响应时间，这些节点可能是路由器、防火墙或者其他网络设备。

---

# 数据链路层

## ARP/RARP协议

ARP（地址解析协议，Address Resolution Protocol）和RARP（逆地址解析协议，Reverse Address Resolution Protocol）是两种用于将IP地址与物理地址（MAC地址）关联的网络协议，它们在局域网（LAN）中扮演着重要角色。在局域网中，当主机或其他网络设备有数据要发送给另一个主机或设备时，它必须知道对方的[网络层](https://so.csdn.net/so/search?q=网络层&spm=1001.2101.3001.7020)地址（即IP地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理网络发送。因此发送方还需要有接收方的物理地址，也就需要一个从IP地址到物理地址的映射，ARP就是事先这么功能的协议。

### 工作流程

1. **ARP请求（广播）**
   - 当主机A需要与主机B通信但未知其MAC地址时，发送ARP广播请求包，包含：
     - 源IP（A的IP）、源MAC（A的MAC）
     - 目标IP（B的IP）、目标MAC（全0或全F）
2. **ARP响应（单播）**
   - 主机B收到请求后，若目标IP与自身匹配，则单播回复ARP响应包，包含：
     - 源IP（B的IP）、源MAC（B的MAC）
     - 目标IP（A的IP）、目标MAC（A的MAC）
3. **缓存更新**
   - 主机A收到响应后，将B的IP-MAC映射存入本地ARP缓存表，默认有效期（通常15-20分钟）。

![ARP协议工作流程](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/ARP%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%2000_00_00-00_00_30.gif?sign=s6JqoO1Hwh-1VXrFOKv5xJcY6znm29CGIxJ8zxJgmeQ=:0)

### ARP欺骗

ARP攻击（Address Resolution Protocol攻击）是一种常见的网络攻击方式，主要利用ARP协议的设计缺陷进行欺骗。ARP协议用于将IP地址解析为MAC地址，以便在局域网中进行通信。攻击者通过伪造ARP数据包，向目标主机发送虚假的ARP应答，从而将目标主机的ARP缓存表中的IP地址与攻击者的MAC地址绑定。

## 以太网协议

以太网是当今现有局域网（Local Area Network, LAN）采用的最通用的通信协议标准，定义了局域网中采用的电缆类型和信号处理方法。   以太网是建立在CSMA/CD（Carrier Sense Multiple Access/Collision Detection，载波监听多路访问/冲突检测）机制上的广播型网络。

### 以太网的发展

#### 1.共享式以太网

共享以太网是多个设备通过共享同一条通信介质（如同轴电缆或集线器）进行数据传输，传输时会先侦听，如果有其他主机也要传输数据，会产生产生冲突。只有侦听时未收到回复，才能进行传输。

![共享式以太网](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E5%85%B1%E4%BA%AB%E5%BC%8F%E4%BB%A5%E5%A4%AA%E7%BD%91.jpg?sign=QL7nl0END5fIiAEDiVgfvZP6EKsAUPFzT_CBf4z-Hrs=:0)

#### 2.交换式以太网

交换式以太网（Switched Ethernet）是一种更高效的以太网工作模式，它通过网络交换机（Switch）将每个设备分配到独立的通信通道，避免了共享式以太网中的冲突和带宽竞争问题。

![交换式以太网](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E4%BA%A4%E6%8D%A2%E5%BC%8F%E4%BB%A5%E5%A4%AA%E7%BD%91.jpg?sign=rMxgbl6F7KOQCwbvvox9C6_BbqPKM_XfF_r_PJhpxog=:0)

### 冲突域

​	**冲突域**是指连接在同一共享介质上的所有节点的集合，冲突域内所有节点竞争同一带宽，一个节点发出的报文（无论是单播、组播、广播），其余节点都可以收到。交换机的每个接口发送和接收数据独立，各个接口属于不同冲突域，有效隔离了物理层冲突域，下图中就包含五个冲突域。在共享网络中，以太网使用**CSMA/CD**技术来避免冲突问题。CSMA/CD的基本工作流程是：

1. 终端设备不断检测共享线路的状态。
2. 如果线路空闲，则发送数据。
3. 如果线路不空闲，则一直等待。
4. 如果有设备同时发送数据，必然会发生冲突，导致线路信号不稳定。
5. 设备检测到信号不稳定后会停止发送数据，并发送干扰脉冲，通知其他设备线路发生冲突。
6. 设备会随机延迟后重发数据。

简单总结为：**先听后发，边发边听，冲突停发，随机延迟后重发**。

![冲突域](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E5%86%B2%E7%AA%81%E5%9F%9F.jpg?sign=ZP1aqLisKyzt-nIdCHSzY3Jf_TX8lj_85Zj4IQjRRVg=:0)

### 广播域

​	广播报文所能到达的整个访问范围称为二层广播域，简称广播域，同一广播域内的主机能收到广播报文。交换机对广播报文会向所有的接口都转发，所以交换机的所有接口连接的节点属于一个广播域。

### 以太网卡

以太网卡（Ethernet Card），也称为网络接口卡（NIC），是计算机或其他设备连接局域网（LAN）的硬件设备。它起到通信桥梁的作用，将设备通过以太网协议连接到网络。

1. **数据封装与解封装**：

- 当设备发送数据时，以太网卡将数据封装为以太网帧（Ethernet Frame）。帧中包含源地址、目标地址、数据负载和校验码等信息。
- 当以太网卡接收到数据时，它解封装以太网帧，提取其中的有效数据并传递给操作系统或上层应用程序。

2. **MAC地址的使用**：   每张以太网卡都有唯一的MAC地址。当设备接收数据时，以太网卡会检查帧中的目标MAC地址是否与自身匹配。如果匹配，则处理数据；否则丢弃。

3. **发送数据**：

- 在以太网中，以太网卡通过连接的介质（如网线）发送数据。
- 如果是在共享网络中（如旧式集线器架构），以太网卡会使用CSMA/CD机制监听线路，避免数据冲突。

4. **接收数据**：   以太网卡持续监听网络上的信号。一旦检测到有数据帧到达，它会读取信号并将其解码为数字数据。

5. **错误检测**：   以太网卡通过帧中的校验码（CRC）检测数据是否在传输过程中损坏。如果检测到错误，会丢弃帧并请求重传。

6. **通信速度与全双工模式**：   现代以太网卡支持不同速率（如10 Mbps、100 Mbps、1 Gbps甚至更高）和全双工通信（同时发送和接收数据）。

### 以太网帧

​	以太网帧（Ethernet Frame）是以太网通信中传输数据的基本单位，包含了多种信息以确保数据可靠传输。

**以太网帧格式：**

以太网帧有两种标准格式：ethernet_II和IEEE 802.3格式。

![以太网帧](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F.jpg?sign=TmlFlJQzBZmmVDXs0wADhegW6aVXbxur3VjU0V4t5h0=:0)

- D.MAC：目标mac地址
- S.MAC：源mac地址
- Type/Length：协议类型/长度
- FCS：帧校验序列，检测数据传输中的错误

### MAC地址

#### MAC地址的表示

​	MAC地址（Media Access Control Address），即媒体访问控制地址，是用于标识网络设备的唯一硬件地址。它通常由网卡制造商分配，并且是设备在局域网（LAN）中通信的重要标识符。MAC地址就像我们的身份证号码，具有唯一性和不可改动性。

![mac地址](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/MAC%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F.png?sign=5skXbnMvRekRpJDNWYPoPmU1gdMa99tZK9YYkyS5D3s=:0)

- MAC地址通常采用“十六进制”加上“-”表示。
- 一个MAC地址有48bit，6Byte。
- MAC地址由48比特，6字节，12位16进制数组成。

#### MAC地址的构成与分类

MAC地址由OUI部分和制造商自己分配的部分组成。

OUI：厂商代码，由IEEE分配，3Byte，24Bit。

制造商分配：3Byte，24Bit。

![mac地址分类](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/MAC%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png?sign=FxKo0CKDClX4Cw0zbuoXp33w3Pk8qs1JYjKt0DQj_QA=:0)

MAC地址可以分为三种类型：
1. **单播MAC地址**：
   - 唯一标识以太网上的一个终端设备，全球唯一。
   - 用于标识链路上的单一节点。
   - 目的地址为单播MAC地址时，数据帧发送至单一节点。
   - 可以作为源地址或目的地址。
   - 注意：单播MAC地址冲突会导致通信故障。
2. **广播MAC地址**：
   - 特定地址：`FF-FF-FF-FF-FF-FF`。
   - 表示局域网中所有终端设备。
   - 数据帧发送至所有链路节点。
   - 是一种特殊的组播MAC地址。
3. **组播MAC地址**：
   - 除广播地址外，第7位为1的地址。
   - 用于标识链路上的一组节点。
   - 数据帧发送至特定组。
   - 仅用作目的地址，不能作为源地址。

### 以太网帧的传播

#### 单播以太网帧

​	单播以太网帧是以太网通信中专门用于点对点通信的数据帧，其中目标MAC地址是唯一的单播MAC地址，指向特定的设备。单播以太网帧封装D.MAC（目的mac地址）时，第一字节的第8个比特为0，表示地址类型。只有局域网中特定的一台设备能收到。

![单播以太网帧](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E5%8D%95%E6%92%AD%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7.jpg?sign=fru1qAv3uYjSjL6JfUz03n6CicT2k-UgMZrDqWL-cis=:0)

#### 广播以太网帧

​	广播以太网帧是用于局域网中向所有设备发送数据的一种特殊帧，其目标地址被设置为广播MAC地址`FF:FF:FF:FF:FF:FF`。广播以太网帧封装D.MAC时，取值全为1，局域网中所有主机都会收到。

![广播以太网帧](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E5%B9%BF%E6%92%AD%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7.jpg?sign=YLm0KIYvzhvb-jNEZe0_RPhK5gWO0WDWushkGpoph-s=:0)

#### 组播以太网帧

​	组播以太网帧是以太网通信中用于向一组特定设备发送数据的一种帧格式，其中目标地址设置为组播MAC地址，只有属于组播组的设备会接收组播帧，其他设备会忽略。组播以太网帧封装D.MAC（目的mac地址）时，第一字节的第8个比特为1，表示地址类型。

![组播以太网帧](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E7%BB%84%E6%92%AD%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7.jpg?sign=EjmpPHQsvhPWZX2k1I3MEEQqH4vIpjmxPlKUMVWWd08=:0)

### IP地址与MAC地址的区别

​	IP地址就像居住地，随着人改变而改变。MAC地址就相当于身份证，从出生到死亡都不会变。在通信过程中，我们会根据“住址”（IP地址）找到人员位置，在比对“身份证号”（MAC地址）确认是否是本人。

**IP地址特点：**

- 一定范围内的IP地址是唯一的
- IP地址是可变的
- 基于网络扩扑进行IP地址分配

**MAC地址特点：**

- MAC地址是唯一的
- MAC地址不可变
- 基于制造商进行MAC地址分配

## 以太网交换机

### 以太网二层交换机

![以太网二层交换机](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA.jpg?sign=Bpi6mQn-8wAOgHGwvPccAzZTXYjRwybyUfS3EQdJ14U=:0)

- **以太网二层交换机**：
  - 在园区网络中，交换机一般来说是距离终端用户最近的设备，用于终端接入园区网，接入层的交换机一般为二层交换机。
  - 二层交换设备工作在TCP/IP对等模型的第二层，即数据链路层，它对数据包的转发是建立在MAC（Media Access Control）地址基础之上的。

- **以太网三层交换机**：
  - 不同局域网之间的网络互通需要由路由器来完成。随着数据通信网络范围的不断扩大，网络业务的不断丰富，网络间互访的需求越来越大，而路由器由于自身成本高、转发性能低、接口数量少等特点无法很好地满足网络发展的需求。因此出现了三层交换机这样一种能实现高速三层转发的设备。

### 交换机工作原理

![交换机工作原理](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png?sign=e1-Fn4KfDJg-6uAbGg0Kcm7nTHZ82q385r3U5KEce4U=:0)

**二层交换机的工作原理**：

- 二层交换机工作在数据链路层，它对数据帧的转发是建立在MAC地址基础之上的。
- 交换机的不同接口可以独立发送和接收数据，这些接口属于不同的冲突域，因此有效地隔离了网络中的冲突域。

**MAC地址表的维护**：

- 二层交换设备通过学习以太网数据帧的源MAC地址来维护MAC地址与接口的对应关系。
- MAC地址表用于根据目的MAC地址决定将数据帧转发到哪个接口。

### MAC地址表

每台交换机中都有一个MAC地址表，存放了MAC地址与交换机端口编号之间的映射关系。

![mac地址表](https://www.cloud.aireelia.com/d/onedrive/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/ip/MAC%E5%9C%B0%E5%9D%80%E8%A1%A8.png?sign=JCHvDZD8XvZctbCcOSdrdFlRTSBSdzwA5Xgna7BOSQg=:0)

**MAC地址表的记录与查询**：

- 交换机记录了学习到的其他设备的MAC地址与接口的对应关系。
- 转发数据帧时，交换机会根据目的MAC地址查询MAC地址表。
- 如果MAC地址表中有匹配的表项，则交换机通过表项中的出接口转发报文。
- 如果MAC地址表中没有匹配表项，交换机将使用泛洪方式，将报文发送到除接收接口外的所有接口。

#### 交换机的MAC地址学习

## VLAN（虚拟局域网）

